# -*- Mode: POLY-ORG ;-*- ---
#+TITLE: GENREC
#+AUTHOR: QH
#+STARTUP: noindent
#+OPTIONS: title:nil toc:nil num:t
#+PROPERTY: header-args :exports both :results_switches ":load no"
#+LATEX_CLASS: genrec-book
#+LATEX_HEADER: \input{preamble.tex}

#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+HTML_HEAD: <style> .example{margin-top:-24px;border-top:none;}</style>
#+HTML_HEAD: <style> div{font-family:sans-serif;}</style>
#+HTML_HEAD: <style> #content{width:calc(65ch + 8em); font-family:Consolas,"Andale Mono WT","Andale Mono","Lucida Console","Lucida Sans Typewriter","DejaVu Sans Mono","Bitstream Vera Sans Mono","Liberation Mono","Nimbus Mono L",Monaco,"Courier New",Courier,monospace;}</style>
#+HTML_HEAD: <style> pre.src{white-space:pre-wrap;}</style>

#+begin_export latex
\frontmatter
\chapterstyle{empty}
\pagestyle{empty}
TODO
\savegeometry{Mem}
\newgeometry{margin=0cm}
\newpage
\twocoltocetc
\tableofcontents*
\loadgeometry{Mem}
\mainmatter
\hypersetup{linkcolor=EFk,urlcolor=EFk}
\chapterstyle{kchan1}
\pagestyle{genrec}
#+end_export
* Introduction
GENREC is a research project that explores stochastic synthesis techniques for general recursive programs.

We are currently focusing on the problem of synthesizing language semantics from examples.
** Getting Started
GENREC is being developed in [[wiki:Literate_Programming][Literate Programming]] style. This Org document serves as both the implementation and the central knowledge repository for the project.

To get started, you should get familiar with [[https://orgmode.org][Org Mode]] and [[wiki:Common_Lisp][Common Lisp]]. Nowadays, people recommend [[https://lispcookbook.github.io/cl-cookbook/][The Common Lisp Cookbook]], read through the sections [[https://lispcookbook.github.io/cl-cookbook/functions.html][Functions]], [[https://lispcookbook.github.io/cl-cookbook/data-structures.html][Data Structures]] and [[https://lispcookbook.github.io/cl-cookbook/macros.html][Macros and Backquote]] and you should be in good position to understand GENREC code. If you encounter some functions/special forms you don't understand, first try search in [[http://clhs.lisp.se/Front/index.htm][Common Lisp Hyper Spec]] (use Google or =M-x slime-hyperspec-lookup=) in case it's in CL standard. If that's not the case, =M-x xref-find-definitions= (usually bound to key =M-.=) will bring you to its source, and typically Lisp source code are well-documented.
- Tip: I highly recommend you to compile and install your own SBCL from source. See [[https://www.sbcl.org/getting.html#compile][Compiling SBCL from Source]].

  This makes the source code for your whole Lisp environment (including the build system, the compiler and the VM itself!) available at runtime, and you can =M-.= into it. I'm not sure how useful this is for newbies -- but I personally find it incredible useful to trouble shoot anything wrong coming from the underlying environment, or if I want to explore and modify the Lisp environment, e.g. for performance reason.
- A few language extensions libraries are ubiquitously used, so it's helpful to get familiar with them just like standard CL.
  - ~bind~ macro from [[https://metabang-bind.common-lisp.dev/user-guide.html][metabang-bind]] to replace ~let~, ~let*~ etc.
  - ~iter~ macro from [[https://iterate.common-lisp.dev/doc/Don_0027t-Loop-Iterate.html][iterate]] as a Lispier replacement of ~loop~
  - Utility collection [[https://alexandria.common-lisp.dev/draft/alexandria.html][alexandria]] (imported via ~:use~) and [[https://github.com/ruricolist/serapeum/blob/master/REFERENCE.md][serapeum]] (with package local nickname ~s~)

You can then start to explore this Org document. This Org document is supposed to be readable -- if you find anything difficult to understand, this is considered a bug! Report to someone in charge. This Org document is a valid Lisp source file at the same time due to a beautiful hack from [[https://github.com/jingtaozf/literate-lisp][literate-lisp]]. The recommended way to load GENREC with all the dependencies is to clone the Git repository to the path ~~/quicklisp/local-projects/genrec~, then ~(ql:quickload "genrec")~.

** Synthesis Technique
We stratify the target program to be synthesized into two parts: A fixed skeleton with holes, and a set of hole-terms that completes the skeleton. We then use stochastic search to find hole-term assignments. The skeleton can use arbitrary Lisp, plus a few macros we provided to define holes. Hole-terms use a restricted grammar so that effective stochastic search is possible.

** Style Guide
*** Blank lines
Blank lines between =org= sections. No blank lines between =lisp= top-level forms.

*** Docstrings
We don't use the traditional uppercase argument convention in docstrings. Instead, always put code between src_lisp{`...'}. i.e., instead of
#+begin_src
(defun foo (bar)
  "Return BAR." ; Legacy convention
  bar)
#+end_src
write
#+begin_src
(defun foo (bar)
  "Return `bar'." ; Our convention
  bar)
#+end_src
This typesets =bar= to inline code by our export procedure, which recognizes src_lisp{`...'} inside docstrings.

The export procedure may produce invalid output for non-idiomatic use of src_lisp{`} and src_lisp{'} symbols. To avoid this, only ever use src_lisp{`} symbol for starting some inline code, and end it with src_lisp{'} symbol immediately followed by either nothing or a /non/-alphanumeric character. The only other valid use of  src_lisp{'} is when immediately followed by an alphanumeric character. The export procedure outputs a src_lisp{'} symbol followed by an alphanumeric character verbatim and does /not/ interpret it as the end of inline code, so that English possessive case (src_lisp{some-noun's}) can be written verbatim.

* Implementation
#+begin_src lisp
(uiop:define-package #:genrec
  (:use #:cl #:iter #:alexandria)
  (:export #:arg-types #:accessors #:constructors #:define-adt #:define-union
           #:hole #:tryable #:with-tryables #:register-tryable-function #:with-skeleton
           #:population-skeleton #:interpreter-skeleton
           #:nested-dispatch-skeleton #:para-skeleton
           #:*restart* #:*search-procedure* #:*eval-toplevel*
           #:solve-skeleton-one-try #:solve-skeleton #:with-profiling
           #:list-of #:boolean #:nat #:zero #:succ #:tuple
           #:defproblem #:inputs-to-examples
           #:call-skeleton #:print-skeleton
           #:deploy-aws-lambda
           #:stratified-solve
           #:fully-connected-skeleton
           #:call-graph-skeleton)
  (:shadowing-import-from #:metabang-bind #:bind)
  (:import-from :serapeum #:defsubst #:defvar-unbound #:eval-always #:ensure)
  #-aws-lambda (:import-from :blackbird #:alet #:catcher)
  (:import-from :sb-cltl2 #:compiler-let))
(in-package #:genrec)
(serapeum:eval-always
  (sb-ext:add-package-local-nickname :t :trivia)
  (sb-ext:add-package-local-nickname :s :serapeum)
  (sb-ext:add-package-local-nickname :l :org.shirakumo.luckless.hashtable))

#+end_src
** Utilities
#+begin_src lisp
(defmacro klet (((name arglist &body cont)) &body body)
  "Stack-allocate a continuation function during evaluation of `body'."
  `(flet ((,name ,arglist . ,cont))
     (declare (dynamic-extent #',name)
              (inline ,name))
     . ,body))
(defsubst compile-lambda (expression)
  (compile nil expression))
#+end_src

Misc CL types:
#+begin_src lisp
(defun return-type (type)
  (t:ematch type ((list 'function _ s-type) s-type)))
(deftype mem () '(simple-array t 1))
#+end_src

We use memoization a lot so here are some macros for it. The comparison is done with ~equal~ predicate on the argument list. Currently, only simple argument list is supported (no ~&optional &rest &key~ etc.). If we ever switch to hash-consing in the future, we may re-implement this memoization macro to boost performance.

- We use =castable= from =luckless=. This is because the CL implementation provided hash table is too slow, both thread-unsafe and thread-safe version. =gethash= can take up to 50% time as profiling shows. Switching to =luckless= fixes this.
- We use =(list* ,@args)= as the key for the memoization hash-table. This is a slight improvement over using =(list ,@args)=, i.e. the argument list as key. We save one cons for every entry, and no extra cons is needed when we have only one argument (=(list* x)= is just =x=).
#+begin_src lisp
(defmacro function-memo (name &rest args)
  `(l:gethash (apply #'list* ',args) (get ',name 'memo-table)))
(defmacro define-memo-function (name args &body body)
  (bind (((:values body decls doc) (parse-body body :documentation t)))
    `(let ((memo-table (l:make-castable :test 'equal)))
       (setf (get ',name 'memo-table) memo-table)
       (defun ,name ,args
         ,doc ,@decls
         (bind ((key (list* ,@args)) ; a bit faster than (list ,@args)
                ((:values result presentp)
                 (l:gethash key memo-table)))
           (if presentp result
               (setf (l:gethash key memo-table) (locally ,@body))))))))
#+end_src
~function-memo~ is intended for overriding the output for some inputs. We use this to add special case for ~nat~ type to ~value-size-function~ and ~edit-distance-function~.

Make =iter= macros generate type declarations to get some free performance benefit:
#+begin_src lisp
(eval-when (:compile-toplevel :load-toplevel :execute)
  (setf iterate::*always-declare-variables* t))
#+end_src

Configure logging system =vom=:
#+begin_src lisp
(vom:config t :info)
#+end_src

Configure asynchronous promise system =blackbird=:
#+begin_src lisp :load no
#-aws-lambda (setq blackbird:*debug-on-error* t)
#+end_src
*** Lazy Evaluation
#+begin_src lisp
(defstruct thunk (function) (result))
(defmacro delay (form)
  `(make-thunk :function (lambda () ,form)))
(defmacro force (maybe-thunk)
  (once-only (maybe-thunk)
    `(if (thunk-p ,maybe-thunk)
         (let ((function (thunk-function ,maybe-thunk)))
           (etypecase function
             (function
              (setf (thunk-function ,maybe-thunk) '%active)
              (prog1 (setf (thunk-result ,maybe-thunk) (funcall function))
                (setf (thunk-function ,maybe-thunk) nil)))
             ((eql %active) (abort-evaluation 'cyclic-thunk))
             ((eql nil) (thunk-result ,maybe-thunk))))
         ,maybe-thunk)))
#+nil (defmacro delay (form) form)
#+nil (defmacro force (form) form)
#+end_src

*** Uneval (for readably-printing with #. syntax)
#+begin_src lisp
(defgeneric uneval (object))
(defmethod uneval ((object t)) object)
(defmethod uneval ((object symbol)) (list 'quote object))
(defmethod uneval ((cons cons))
  (let ((car-form (uneval (car cons)))
        (cdr-form (uneval (cdr cons))))
    (if (and (constantp car-form) (constantp cdr-form))
        (list 'quote cons)
        (t:match cdr-form
          ((list* 'list rest)
           (list* 'list car-form rest))
          (nil (list 'list car-form))
          (_ (list 'cons car-form cdr-form))))))
(defmethod uneval ((function function))
  (bind (((:values expr closure-p) (function-lambda-expression function)))
    (unless (and (not closure-p) expr)
      (error "Don't know how to UNEVAL function ~a." function))
    expr))
(defun uneval-print-object (object stream)
  (format stream "#.~s" (uneval object)))
#+end_src

*** TODO Hash-consing
We manipulate terms a lot. Will switching to hash-consing boost performance?

It will probably not if we use the CL implementation provided hash table, which is really slow. =luckless= might have a chance, but still keep in mind that =cons= might be faster than you think and hash tables might be slower than you think!

** Type utilities
Here we have a poor man's polymorphic type system:
- A /type/ can be either a symbol (e.g. ~nat~) or a list with a symbol in its =car= (e.g. ~(list-of nat)~)
- A type has some /constructors/. This is either the type's (if it's a symbol) or its =car='s (if it's a list) ~'constructors~ symbol property.

  A constructor (always a symbol) is called to make an object if its function cell is bound, e.g. ~cons~. Otherwise, it's regarded as a constant and stand for itself, e.g. ~nil~.
- A constructor has some /accessors/ to access its fields.
- Given a constructor and the expected ~result-type~, ~arg-types~ compute the expected list of argument type. This allows us to do some polymorphism, e.g.

  #+begin_src lisp :load no :results value verbatim
  (arg-types 'cons '(list-of nat))
  #+end_src

  #+RESULTS:
  : (NAT (LIST-OF NAT))

These mechanisms for constructors are also used for our handling of library functions, so that e.g. ~nth~ works on ~(list-of *)~ for any ~*~.
#+begin_src lisp
(defun constructors (type)
  (append (when (consp type) (constructors (car type)))
          (when (symbolp type) (get type 'constructors))))
(defun accessors (c) (get c 'accessors))
(defun arg-types (f result-type)
  (if (functionp (get f 'arg-types))
      (funcall (get f 'arg-types) result-type)
      (get f 'arg-types)))
(defun (setf constructors) (new-val type)
  (assert (symbolp type))
  (setf (get type 'constructors) new-val))
#+end_src

*** Recursive constructors
A constructor is /recursive/ if some of its argument type "contains" its result type. In a few cases we test and treat recursive types specially. Specifically, in =para-skeleton= (which does not use lazy evaluation) we only generate nested loops for recursive branches to avoid infintie regress. This treatment is somewhat ad-hoc and does not work nicely with mutually recursive types, so we have been avoiding it for other skeletons and use lazy evaluation to avoid infinite regress instead.
#+begin_src lisp
(defun type-contains-p (type child-type)
  (let ((visited (make-hash-table :test 'equal)))
    (labels ((process (type)
               (or (equal type child-type)
                   (unless (gethash type visited)
                     (setf (gethash type visited) t)
                     (some (lambda (c)
                             (some #'process (arg-types c type)))
                           (constructors type))))))
      (process type))))
(defun recursive-p (c result-type)
  (some (lambda (type) (type-contains-p type result-type)) (arg-types c result-type)))
#+end_src

*** Library function index
We index library functions according to return type, so that ~generate-mutations~ can retrieve them efficiently using helper ~library-functions~. It's similar to ~constructors~. To locally add some library function, dynamically bind ~*library-table*~.
#+begin_src lisp
(defvar *library-table* (make-hash-table :test 'equal)
  "Map return types to lists of library functions.")
(defun library-functions (result-type)
  "Return the list of library functions that returns `result-type'."
  (append (when (consp result-type)
            (library-functions (car result-type)))
          (gethash result-type *library-table*)))
#+end_src

*** Representation of values using CL types
For a fully specialized type, each constructor should construct runtime value of distinct Common Lisp types. This is how we tell them apart. E.g.
- For ~(list-of *)~, ~cons~ always construct object of type ~cons~ and ~nil~ always construct object of type ~(eql nil)~.
- For ADTs defined as the union of several product (i.e. CL struct) type, each constructor construct the corresponding CL struct.
#+begin_src lisp
(defun constructor->cl-type (c)
  (or (get c 'cl-type)
      (if (sb-cltl2:function-information c)  c `(eql ,c))))
#+end_src
See [[Built-in Types]] for some examples of using this low level interface. If polymorphism is not needed, we recommend using ~define-adt~.

*** Default terms and values
When we pick initial hole-terms for a search, or construct new application in a hole-term, we need to fill in some default hole-term with a given type, if no better option is available. Default value for a type is used in ~value-size~ and ~edit-distance~. The following computes default hole-term and value.

#+begin_src lisp
(define-memo-function min-constructor (type)
  "The non-recursive constructor of TYPE with smallest arity."
  (let ((cs (sort (remove-if (lambda (c) (member type (arg-types c type) :test 'equal))
                             (constructors type))
                  #'< :key (lambda (c) (length (arg-types c type))))))
    (unless cs
      (error "Type ~a has no non-recursive base case!" type))
    (car cs)))
(define-memo-function default-term (type)
  (let ((minc (min-constructor type)))
    (cons minc (mapcar #'default-term (arg-types minc type)))))
(define-memo-function default-value (type)
  (let ((minc (min-constructor type)))
    (if (fboundp minc)
        (apply minc (mapcar #'default-value (arg-types minc type)))
        minc)))
#+end_src

***** TODO To reduce some bias, try to use full set of non-recursive values (rather than the smallest ones).
Update ~generate-mutations~, ~value-size~ and ~edit-distance~ accordingly, the latter two should test for non-recursive base cases rather than comparing to ~default-value~. Will this have any benefits?

** Convenient ADT definition
See [[Lambda Calculus (de Brujin index)]] for an example.
#+begin_src lisp
(defun invalidate-memo (type)
  (mapc (lambda (symbol)
          (l:remhash type (get symbol 'memo-table)))
        '(min-constructor
          default-term
          default-value
          value-size-function
          edit-distance-function)))

(defmacro define-adt (name &body constructors)
  `(eval-always
     (invalidate-memo ',name)

     ,@(mapcan
         (t:lambda-match1 (list* c args)
           (when args
             `((defstruct (,c (:constructor ,c ,(mapcar #'car args))
                              (:print-object uneval-print-object))
                 ,@(mapcar #'car args))
               (defmethod uneval ((object ,c))
                 (list ',c ,@(mapcar (lambda (arg) `(uneval (,(symbolicate c "-" (car arg)) object))) args))))))
         constructors)
     (deftype ,name ()
       '(or ,@(mapcar (t:lambda-match1 (list* c args)
                        (if args c `(eql ,c)))
               constructors)))

     ,@(mapcar (t:lambda-match1 (list* c args)
                  (bind ((fields (mapcar #'car args))
                         (types (mapcar #'cadr args))
                         (accessors
                          (mapcar (lambda (f) (symbolicate c "-" f)) fields)))
                    `(progn
                       (declaim
                        ,@(mapcar
                           (lambda (a type) `(ftype (function (,c) ,type) ,a))
                           accessors types))
                       (setf (get ',c 'arg-types) ',types
                             (get ',c 'accessors) ',accessors))))
                constructors)
     (setf (constructors ',name) ',(mapcar #'car constructors))))
#+end_src

#+begin_src lisp
(defmacro define-union (name &rest members)
  `(eval-always
     (invalidate-memo ',name)
     (deftype ,name ()
       '(or ,@members))
     (setf (constructors ',name)
           #+nil (list (min-constructor ',(car members)))
           (append ,@(mapcar (lambda (member) `(constructors ',member)) members)))))
#+end_src

*** TODO Support type parameter/variable

** Hole-terms
/Hole-terms/ are basically a first-order subset of regular lisp, with only function applications and special ~(tryable n)~ forms.
- ~(tryable n)~ denotes the n-th tryable value.

We use a simple "compiler" that translate a hole-term into an /execution procedure/ (chain of closures).
- An execution procedure is a callable function.
  When called with a single argument (the vector of tryable values), it returns the value represented by the source hole-term.

The reason we have this simple compiler is that interpreting hole-terms at evaluation time is slow, but SBCL compiler is super slow, so we can't afford to generate Lisp code and call ~compile~ for every hole-term.

*** TODO Explore machine code generator for hole-terms
Maybe try SBCL's assembler ~sb-assem~
- [[https://pvk.ca/Blog/2014/03/15/sbcl-the-ultimate-assembly-code-breadboard/][SBCL: the ultimate assembly code breadboard]]

... or Clozure CL's LAP (lisp assembly program)

#+begin_export latex
\begin{CJK}{UTF8}{gbsn}
#+end_export

- 在 Clozure Common Lisp 中使用汇编 (in Chinese)
  - [[https://xfy.vercel.app/posts/write-assembly-code-in-ccl/][编写 LAP 代码]]
  - [[https://xfy.vercel.app/posts/debug-ccl-using-gdb/][使用 GDB 调试]]

#+begin_export latex
\end{CJK}
#+end_export

*** Chain of closure compiler for hole-terms
~make-cons-procedure~ is a helper to construct execution procedures that apply a function to a list of mixed static and dynamic arguments. This remove the overhead to create and call trivial constant procedures (of the form ~(lambda (mem)~ /some-constant/ ~)~) for every constant terms. Instead, the static constants are embedded in the caller execution procedure. I deem this worthy because we have plenty of use of ~0~'s and ~nil~'s etc., but we won't ever (I think) use a large set of distinct constant.

The canonical example use: ~(funcall (make-cons-procedure f '(t nil nil))~ /execution-procedure_1/ /constant_1/ /constant_2/​~)~ gives something equivalent to ~(lambda (mem) (f (funcall~ /execution-procedure_1/ ~mem)~ /constant_1/ /constant_2/​~))~, with /execution-procedure_1/ /constant_1/ and /constant_2/ closed in closures variables.
#+begin_src lisp
(define-memo-function make-cons-procedure (f dynamic-p-list)
  "Partially specialize F according to DYNAMIC-P-LIST."
  (if (fboundp f)
      (if (or (some #'identity dynamic-p-list)
              ;; recognize skeleton local functions
              (not (symbol-package f)))
          (let ((*gensym-counter* 0)
                (args (make-gensym-list (length dynamic-p-list) "ARG-")))
            (compile-lambda
             `(lambda ,args
                (lambda (mem)
                  (declare (optimize (speed 3) #+nil (safety 0)))
                  (,f ,@(mapcar
                         (lambda (dynamic-p arg)
                           (if dynamic-p
                               `(funcall (the function ,arg) mem)
                               arg))
                         dynamic-p-list args))))))
          f)
      (constantly f)))
#+end_src

We represent parameter sequences as lists of hole-terms for easier manipulation (useful for computing mutations) and as simple vectors for efficient execution (useful for plugging into skeletons and evaluating the resulting candidate programs). The following compiles the former representation into the latter.
#+begin_src lisp
(defsubst compound-term-p (term)
  "Return `t' if `term' is an application."
  (and (consp term) (not (eq (car term) 'tryable))))
(defun term->procedure (term lazy-evaluation-p)
  "Convert `term' to an execution procedure."
  (labels ((process (term)
             (t:match term
               ((list 'succ _)
                (iter (for i from 1)
                  (setq term (cadr term))
                  (while (and (consp term) (eq (car term) 'succ)))
                  (finally
                   (let ((arg (process term)))
                     (return
                       (if (functionp arg)
                           (named-lambda add-procedure (mem)
                             (+ i (funcall arg mem)))
                           (+ i arg)))))))
               ((list 'tryable index)
                (if lazy-evaluation-p
                    (named-lambda tryable-procedure (mem)
                      (force (svref mem index)))
                    (named-lambda tryable-procedure (mem)
                      (svref mem index))))
               ((list* op args)
                (let ((args (mapcar #'process args)))
                  (apply
                   (make-cons-procedure op (mapcar #'functionp args))
                   args))))))
    (let ((result (process term)))
      (if (functionp result) result
          (named-lambda const-procedure (mem)
            (declare (ignore mem))
            result)))))
(defun compile-par (par lazy-evaluation-p)
  "Convert a list of hole-terms into a simple vector of execution procedures."
  (map 'vector (lambda (term) (term->procedure term lazy-evaluation-p)) par))
#+end_src
** Skeleton Language
*** Resource Limit Helpers
We guards against two kinds of resource exhaustions:
- Executions that are too long, or worse, never terminates. They consume computation budget without making significant progress. We guards against them by incrementing and checking a counter =*pc*= at every =check-resource-limit=.
- Executions that use too much stack space. In the worst case, this crashes the entire Lisp image. We guards against them by using SBCL internal operations to check current stack pointer location at every =check-resource-limit=.
#+begin_src lisp
(defvar *stack-limit*) (defvar *pc*)
(defun call-with-resource-limit (thunk)
  (let ((*stack-limit*
          (- (sb-sys:%primitive sb-c:current-stack-pointer)
             16384))
        (*pc* 200))
    (funcall thunk)))
(defmacro with-resource-limit (&body body)
  `(call-with-resource-limit (lambda () ,@body)))
(defun abort-evaluation (reason)
  (declare (ignore reason))
  (throw 'cost 1000.0))
(declaim (inline check-resource-limit))
(defun check-resource-limit ()
  (decf *pc*)
  (unless (> *pc* 0)
    (abort-evaluation 'pc))
  (unless (> (sb-sys:%primitive sb-c:current-stack-pointer)
             *stack-limit*)
    (abort-evaluation 'stack)))
#+end_src

**** TODO Alternatives to checking =*pc*=
We could check real running time instead. This can be implemented by either accessing system clock at every =check-resource-limit=, or by setting up a timer before the start of every candidate program execution. Both strategies might have (much) higher overhead comparing to current approach, but neither have been thoroughly explored yet.

*** Skeleton definition

A /procedure generator/ is a procedure that takes a vector of execution procedures (bound to lexical variable =%par%=) and returns a list of completed procedures. Use ~compile-par~ to compile a sequence of hole-terms into a suitable value to pass to the procedure generator.
#+begin_src lisp
(deftype procedure-generator () '(function ((list-of function)) (list-of function)))
(defstruct (skeleton (:print-object uneval-print-object))
  (holes (error "Unprovided.") :type list)
  (type (error "Unprovided."))
  (generator (error "Unprovided.") :type procedure-generator)
  (source)
  (lazy-evaluation-p))
(defmethod uneval ((object skeleton)) (skeleton-source object))
(defstruct hole (type) (tryable-types) (function))
(defmethod make-load-form ((object hole) &optional env)
  (make-load-form-saving-slots object :environment env))
(defun skeleton-functions (skeleton par)
  (funcall (skeleton-generator skeleton)
           (compile-par par (skeleton-lazy-evaluation-p skeleton))))
#+end_src

~hole~, ~with-tryables~ and ~with-skeleton~ are the main macros for defining skeletons.
#+begin_src lisp
(defvar *holes* (s:vect))
(defvar *tryable-vars* nil)
(defvar *tryable-types* nil)
(defvar *function-index* nil "Metadata for debugging. Recorded into `hole-function'.")
(defmacro hole-1 (index &rest exprs)
  `(let ((mem (vector ,@exprs)))
     (declare (dynamic-extent mem))
     (funcall (the function (svref %par% ,index)) mem)))
(defmacro hole (type)
  "A hole with `type'.
At evaluation time, this computes a value from `%par%' variable and the lexically defined set of tryable expressions. See `with-tryables'."
  (prog1 `(hole-1 ,(length *holes*) ,@*tryable-vars*)
    (vector-push-extend
     (make-hole :type type :tryable-types *tryable-types*
                :function *function-index*)
     *holes*)))
(defun gensym-1 (thing)
  (gensym (string-trim
           "-"
           (coerce
            (mapcan (lambda (c)
                      (cond ((alpha-char-p c) (list c))
                            ((alphanumericp c) nil)
                            (t (list #\-))))
                    (coerce (format nil "~a" thing) 'list))
            'string))))
(defmacro with-tryables (exprs-and-types &body body)
  "`exprs-and-types' should be of the form `((expr type) ...)'.
Make `expr' tryable for `hole' forms in `body'."
  (bind ((exprs (mapcar #'car exprs-and-types))
         (types (mapcar #'cadr exprs-and-types))
         (vars (mapcar #'gensym-1 types)))
    `(let ,(mapcar #'list vars exprs)
       (compiler-let
           ((*tryable-vars* ',(append vars *tryable-vars*))
            (*tryable-types* ',(append types *tryable-types*)))
         ,@body))))
(defmacro with-tryables* (exprs-and-types &body body)
  "Like `with-tryables', but make values of previous bindings tryable in later bindings."
  (if exprs-and-types
      `(with-tryables (,(car exprs-and-types))
         (with-tryables* ,(cdr exprs-and-types)
           ,@body))
      `(progn ,@body)))
(defmacro letrec (bindings &body body)
  `(let ,(mapcar #'car bindings)
     ,@ (mapcar (lambda (b) `(setq ,@b)) bindings)
     ,@body))
(defmacro with-tryables-rec (exprs-and-types &body body)
  (bind ((exprs (mapcar #'car exprs-and-types))
         (types (mapcar #'cadr exprs-and-types))
         (vars (mapcar #'gensym-1 types)))
    `(compiler-let
         ((*tryable-vars* ',(append vars *tryable-vars*))
          (*tryable-types* ',(append types *tryable-types*)))
       (letrec ,(mapcar #'list vars exprs) ,@body))))
(defun add-library-function (name return-type)
  "Add library function to `*library-table*' at evaluation time."
  (push name (gethash return-type *library-table*)))
(defmacro with-skeleton (&whole source
                         (&key (type (error "Type must be provided."))
                            lazy-evaluation-p)
                         &body body)
  (let ((holes (s:vect)))
    `(compiler-let ((*holes* ,holes))
       (let ((holes-vector ',holes))
         (make-skeleton :generator (lambda (%par%) ,@body)
                        :holes (map 'list #'identity holes-vector)
                        :type ',type
                        :source ',source
                        :lazy-evaluation-p ',lazy-evaluation-p)))))
#+end_src

** Skeleton Generators
Skeleton generators are written as macros. By convention, we use ~compiler-let~ to pass down expected output type via ~*output-type*~, so that skeleton generator macros can do return-type polymorphism. Each skeleton generator macro should also do so for their sub-forms.
#+begin_src lisp
(defvar *output-type* nil "Intended output type for current macro at code generation time.")
#+end_src

*** Code Generator Debugging
SLIME macrostepper is a convenient tool for debugging these code generators, such as ~population-skeleton~.
- To use the macrostepper, install Emacs package [[https://melpa.org/#/macrostep][~macrostep~]] and SLIME will integrate its macroexpander into it (if not, try restart SLIME or Emacs). Then ~M-x macrostep-expand~ on the macro form you want to expand.
- When expanding interactively using  ~slime-macrostep~, the displayed =INDEX= for ~hole-1~ forms are usually errorneous. Don't worry! They are expanded to correct values by SBCL evaluator.

To examine =INDEX= of holes in the parameter sequence, (e.g. when manually crafting a parameter sequence to test a skeleton), the following helpers (~macroexpand-holes~ being the most covenient one) let us correctly (more so than =slime-macrostep=!) expand some macros but retain the rest. We can use it to selectively expand code generator macros and ~hole~ forms without turning them into low-level unreadable mess.

~macroexpand-some~ uses a clever hack inspired by =slime-macrostep=. Note that it's not sufficient to just call [[http://clhs.lisp.se/Body/f_mexp_.htm][~macroexpand~]] until we reach a form we don't want to expand -- the arguments of that form might still contain interesting macro forms, but it's not possible to tell whether they are in evaluated positions without extensive analysis. Instead, we use =sb-int:eval-in-lexenv= to evaluate the original form, expanding fully in the process, and use [[http://clhs.lisp.se/Body/v_mexp_h.htm][~*macroexpand-hook*~]] to collect substitutions. We then apply an interesting subset of these substitutions ourselves to the original form until fixed-point.
- =sb-cltl2:macroexpand-all= has slightly different behavior from the macro expansion process performed by actual SBCL evaluator. Don't use it -- it causes subtle bugs, e.g., the order of holes in =*holes*= are wrong!
#+begin_src lisp
(defun collect-expansion-alist (form &optional env)
  "Expand all macro forms in FORM and returns all substitutions performed."
  (bind ((expansion-alist)
         (*macroexpand-hook*
          (lambda (macro-function form env)
            (let ((result (funcall macro-function form env)))
              (push (cons form result) expansion-alist)
              result))))
    (sb-int:eval-in-lexenv form env)
    expansion-alist))

(defun apply-expansion-alist (form expansion-alist)
  (iter (for old-form = form)
    (setq form (sublis expansion-alist form))
    (until (equal form old-form)))
  form)

(defun macroexpand-some (form predicate &optional env)
  "Expand all macro forms in `form' which satisfies `predicate'."
  (bind ((expansion-alist (collect-expansion-alist form env))
         (selected-expansions
          (remove-if-not (lambda (subst)
                           (funcall predicate (car subst)))
                         expansion-alist)))
    (apply-expansion-alist form selected-expansions)))

#+end_src

The following ~macroexpand-till~ is an even smarter variation. It performs just enough expansions so that all forms satisfying ~predicate~ are exposed and expanded in the result. The required set of expansions is computed via set fix point.
#+begin_src lisp
(defun form-contains (form subform)
  (or (eq form subform)
      (when (consp form)
        (or (form-contains (car form) subform)
            (form-contains (cdr form) subform)))))

(defun macroexpand-till (form predicate &optional env)
  "Expand enough macros in form to expose expansions of every subform satisfying `predicate'."
  (setq form (copy-tree form)) ;; Remove any structural sharing
  (bind ((expansion-alist (collect-expansion-alist form env))
         (selected-expansions
          (remove-if-not (lambda (subst)
                           (funcall predicate (car subst)))
                         expansion-alist)))
    (iter (for old-selected-expansions = selected-expansions)
      (setq selected-expansions
            (remove-if-not
             (lambda (subst)
               (or (member subst selected-expansions)
                   (some (lambda (subst-1)
                           (and (not (form-contains (car subst) (car subst-1)))
                                (form-contains (cdr subst) (car subst-1))))
                         selected-expansions)))
             expansion-alist))
      (until (equal old-selected-expansions selected-expansions)))
    (apply-expansion-alist form selected-expansions)))
#+end_src

It is especially useful to expand the skeletons enough so that we can see all holes, but also avoid unnecessary expansions which clutters the result. This fucntionality is provided below.
#+begin_src lisp
(defun macroexpand-holes (form)
  "Expand enough macros in `form' to expose every `hole' subform."
  (macroexpand-till form (lambda (form) (eq (car form) 'hole))))
#+end_src

#+begin_src lisp
(defun substitute-tryables (term vars)
  "Substitute `(tryable n)' subterms in `term' with n-th `vars'."
  (labels ((process (term)
             (if (consp term)
                 (if (eq (car term) 'tryable)
                     (nth (cadr term) vars)
                     (mapcar #'process term))
                 term)))
    (process term)))
(defun normalize-const-constructors (term)
  "Replace zero-arity constructors like `(c)' with `(quote c)'."
  (labels ((process (term)
             (if (consp term)
                 (if (and (not (cdr term))
                          (not (fboundp (car term))))
                     (list 'quote (car term))
                     (mapcar #'process term))
                 term)))
    (process term)))
(defun substitute-holes (form par)
  "Instantiate hole terms of the form `(hole-1 n ...)' according to parameter sequence `par'."
  (labels ((process (form)
             (if (consp form)
                 (if (eq (car form) 'hole-1)
                     (substitute-tryables
                      (normalize-const-constructors (nth (cadr form) par))
                      (cddr form))
                     (mapcar #'process form))
                 form)))
    (process form)))
#+end_src

The output of macroexpansion are sometimes quite verbose and hard to read. The following perform some simplifications to improve readability:
- Remove =compiler-let=, which are no-op after macroexpansion phase.
- Remove unnecessary =progn=.
- Merge consecutive nested =let='s into =let*=.
- Substitute in let bindings.
#+begin_src lisp
(defun simplify-cl (form)
  "Simplify Common Lisp code `form' for readability."
  (labels ((expand-binding-p (binding)
             #+nil (and (listp binding)
                        (symbolp (cadr binding)))
             (declare (ignore binding))
             t)
           (process (form)
             (t:match form
               ((list* 'compiler-let _ body) (process (cons 'progn body)))
               ((list 'progn expr) (process expr))
               ((list 'let nil expr)
                (process expr))
               ((list 'let bindings (cons 'progn body))
                (process (list* 'let bindings body)))
               ((list 'let bindings expr)
                (bind (((:values subst kept)
                        (s:partition #'expand-binding-p bindings))
                       (alist (mapcar (lambda (b) (cons (car b) (cadr b))) subst))
                       (expr (process (sublis alist expr))))
                  (if kept (list 'let kept expr) expr)))
               ((list 'letrec bindings expr)
                (bind ((alist
                        (mapcar (t:lambda-match
                                  ((list var (list 'delay expr))
                                   (cons var expr))
                                  ((list var expr)
                                   (cons var expr)))
                                bindings)))
                  (iter (for old-expr = expr)
                    (for i below 5)
                    (setq expr (sublis alist expr))
                    (until (equal old-expr expr)))
                 (process expr)))
               ((list 'let (list binding) expr)
                (t:match (process expr)
                  ((list* 'let* bindings body)
                   (list* 'let* (cons binding bindings) body))
                  ((list* 'let (list binding-1) body)
                   (list* 'let* (list binding binding-1) body))
                  (expr (list 'let (list binding) expr))))
               ((type cons) (mapcar #'process form))
               (_ form))))
    (iter (for old-form = form)
      (setq form (process form))
      (until (equal old-form form)))
    form))
#+end_src

Finally, putting all the pieces together, we have a pretty printer for skeletons that substitute in a given parameter sequence.
#+begin_src lisp
(defun print-skeleton (skeleton par)
  (let ((*gensym-counter* 0)
        (*print-circle* nil)
        (*print-gensym* nil))
    (print (simplify-cl
            (substitute-holes
             (macroexpand-till (skeleton-source skeleton)
                               (lambda (form) (member (car form)
                                                      '(hole with-tryables with-tryables*
                                                        with-tryables-rec))))
             par)))
    (values)))
#+end_src

*** Call graph of Single dispatch functions

A set of mutually recursive function, each dispatching on their first argument.
#+begin_src lisp
(defvar *dispatch-1-default-clauses* nil)
(defmacro dispatch-1 (dispatch-value dispatch-type &body clauses)
  "Single dispatch on `dispatch-value' and make its field members tryable.
`clauses' should be of the form `((constructor body...) ...)'"
  (once-only (dispatch-value)
    `(etypecase ,dispatch-value
       ,@(mapcar (t:lambda-ematch1 (list* c body)
                   `(,(constructor->cl-type c)
                     (with-tryables
                         ,(mapcar (lambda (accessor field-type)
                                    `((,accessor ,dispatch-value) ,field-type))
                                  (accessors c) (arg-types c dispatch-type))
                       ,@body)))
          clauses)
       ,@*dispatch-1-default-clauses*)))
(defmacro call-with-holes (function input-types)
  "Calls `function' with holes with `input-types'."
  `(delay (,function ,@(mapcar (lambda (type) `(hole ,type)) input-types))))
(defmacro with-tryable-applications (function-and-types &body body)
  `(with-tryables-rec
       ,(mapcar
         (t:lambda-ematch1 (list f type)
           (bind (((_ input-types output-type) type))
             `((call-with-holes ,f ,input-types) ,output-type)))
         function-and-types)
     ,@body))
(defun single-dispatch-function-binding
    (callable-functions callable-function-types
     this-function type function-index)
  (bind (((_ input-types output-type) type)
         (args (mapcar #'gensym-1 input-types))
         (dispatch-type (car input-types)))
    `(,this-function
      ,args
      (check-resource-limit)
      (compiler-let ((*function-index* ,function-index)
                     (*gensym-counter* 0))
        (with-tryables ,(mapcar #'list args input-types)
          (dispatch-1 ,(car args) ,dispatch-type
                      ,@(mapcar
                         (lambda (c)
                           `(,c
                             (with-tryable-applications
                               #+nil ,(reverse (mapcar #'list
                                                       (append function-names function-names)
                                                       (append types types)))
                               ,(mapcar #'list callable-functions
                                        callable-function-types)
                               (hole ,output-type))))
                         (constructors dispatch-type))))))))
#+end_src

#+begin_src lisp
(defmacro call-graph-skeleton (&rest clauses)
  "Each of `clauses' must have the form `(name type . callable-functions)'.
Special case: if a clause is of the form  `(name type :code arg-list . body)',
a function with `arg-list' and `body' is generated verbatim."
  `(with-skeleton (:type ,(cadr (lastcar clauses)) :lazy-evaluation-p t)
     (labels
         ,(iter
            (for (name type . callable-functions) in clauses)
            (for i from 0)
            (collect
                (if (eq (car callable-functions) :code)
                    (cons name (cdr callable-functions))
                    (single-dispatch-function-binding
                     callable-functions
                     (mapcar (lambda (f) (cadr (assoc f clauses)))
                             callable-functions)
                     name type i))))
       (list ,@(iter (for (name) in clauses) (collect `#',name))))))
(defmacro fully-connected-skeleton (&rest types)
  (bind ((function-names (make-gensym-list (length types) "F")))
    `(call-graph-skeleton
      ,@ (iter
           (for name in function-names)
           (for type in types)
           (collect `(,name ,type ,@function-names))))))
#+end_src

*** Interpreter Skeleton (Fully connected Single-dispatch functions with open recursion)
#+begin_src lisp
(defvar *eval-toplevel* nil)
(defun convert-toplevel-function-binding (binding)
  (t:ematch binding
    ((list* name args body)
     (bind (((:values body decls) (parse-body body)))
       `(,name
         ,args
         ,@decls
         (compiler-let
             ((*dispatch-1-default-clauses* '((t (funcall *eval-toplevel* ,@args)))))
           ,@body))))))
(defmacro interpreter-skeleton (term-type &body types)
  (bind ((main-type (lastcar types))
         (function-names (make-gensym-list (length types) "F"))
         (function-bindings
          (mapcar (curry #'single-dispatch-function-binding
                          function-names
                          (append (butlast types)
                                  (list
                                   (t:ematch (lastcar types)
                                     ((list 'function (cons _ input-types) output-type)
                                      (list 'function (cons term-type input-types) output-type))))))
                  function-names types (iota (length types)))))
    (setq function-bindings (append (butlast function-bindings)
                                    (list (convert-toplevel-function-binding
                                           (lastcar function-bindings)))))
    `(with-skeleton (:type ,main-type :lazy-evaluation-p t)
       (labels
           ,function-bindings
         ,@(mapcar (lambda (name) `(setf (symbol-function ',name) #',name)) function-names)
         ,@(mapcar (lambda (name type) `(setf (get ',name 'arg-types) ',(cadr type)))
                   function-names types)
         (list ,@(mapcar (lambda (s) `#',s) function-names))))))
#+end_src

#+begin_src lisp
(defclass dispatch-eval ()
  ((arg-list :initarg :arg-list)
   (dispatch-list :initarg :dispatch-list))
  (:metaclass closer-mop:funcallable-standard-class))
(defmethod initialize-instance ((self dispatch-eval) &key arg-list dispatch-list)
  (closer-mop:set-funcallable-instance-function
   self
   (compile-lambda
    `(lambda (,@arg-list)
       (etypecase ,(car arg-list)
         ,@ (iter (for (type skeleton par) in dispatch-list)
              (collect
                  `(,type
                    (funcall
                     ,(alexandria:lastcar
                       (genrec::skeleton-functions
                        (resolve-variable skeleton)
                        par))
                     ,@arg-list))))))))
  (call-next-method))
(defmethod uneval ((self dispatch-eval))
  (with-slots (arg-list dispatch-list) self
    `(make-instance 'dispatch-eval
                    :arg-list ,(uneval arg-list)
                    :dispatch-list ,(uneval dispatch-list))))
#+end_src

*** Top-level recursion with nested dispatch
#+begin_src lisp
(defmacro nested-dispatch (function-type &rest dispatch-types)
  (t:match dispatch-types
    ((cons dispatch-type rest)
     `(dispatch-1 (hole ,dispatch-type) ,dispatch-type
        ,@(mapcar
           (lambda (c)
             `(,c
               (with-tryable-applications
                   ,(make-list 2 :initial-element (list 'f function-type))
                 (nested-dispatch ,function-type ,@rest))))
           (constructors dispatch-type))))
    (nil `(hole ,*output-type*))))
(defmacro nested-dispatch-skeleton (function-type &rest dispatch-types)
  (bind (((_ input-types output-type) function-type)
         (args (mapcar #'gensym-1 input-types)))
    `(with-skeleton (:type ,function-type)
       (labels ((f ,args
                  (check-resource-limit)
                  (with-tryables ,(mapcar #'list args input-types)
                    (compiler-let ((*output-type* ',output-type))
                      (nested-dispatch ,function-type ,@dispatch-types)))))
         (list #'f)))))
#+end_src

** Paramorphism
Properly-nested [[wiki:paramorphism][paramorphism]].
#+begin_src lisp
(defmacro para (dispatch-value dispatch-type &rest clauses)
  `(labels ((process (dispatch-value)
              (check-resource-limit)
              (dispatch-1 dispatch-value ,dispatch-type
                ,@(mapcar
                   (t:lambda-ematch1 (list* c body)
                     `(,c
                       (with-tryables
                           ,(s:filter-map
                             (lambda (a field-type)
                               (when (equal field-type dispatch-type)
                                 `((process (,a dispatch-value))
                                   ,dispatch-type)))
                             (accessors c)
                             (arg-types c dispatch-type))
                         ,@body)))
                   clauses))))
     (process ,dispatch-value)))
(defmacro properly-nested-para (&rest dispatch-types)
  (t:match dispatch-types
    ((cons type rest)
     `(para (hole ,type) ,type
            ,@(mapcar
               (lambda (c)
                 `(,c
                   ,(if (recursive-p c type)
                        `(properly-nested-para ,@rest)
                        `(hole ,*output-type*))))
               (constructors type))))
    (nil `(hole ,*output-type*))))
(defmacro para-skeleton (function-type &rest dispatch-types)
  (bind (((_ input-types output-type) function-type)
         (args (mapcar #'gensym-1 input-types)))
    `(with-skeleton (:type ,function-type)
       (list (lambda ,args
               (with-tryables ,(mapcar #'list args input-types)
                 (compiler-let ((*output-type* ',output-type))
                   (properly-nested-para ,@dispatch-types))))))))
#+end_src

#+begin_src lisp :load no :results output code
(macroexpand-some
 '(para-skeleton (function (nat nat) nat) nat nat nat)
 (lambda (form) (member (car form) '(para-skeleton properly-nested-para))))
#+end_src

#+RESULTS:
#+begin_src lisp :load no
(WITH-SKELETON (:TYPE (FUNCTION (NAT NAT) NAT))
  (LIST
   (LAMBDA (#:NAT458 #:NAT459)
     (WITH-TRYABLES ((#:NAT458 NAT) (#:NAT459 NAT))
       (COMPILER-LET ((*OUTPUT-TYPE* 'NAT))
                     (PARA (HOLE NAT) NAT (ZERO (HOLE NAT))
                           (SUCC
                            (PARA (HOLE NAT) NAT (ZERO (HOLE NAT))
                                  (SUCC
                                   (PARA (HOLE NAT) NAT (ZERO (HOLE NAT))
                                         (SUCC (HOLE NAT))))))))))))
#+end_src

** Search operators
*** Non-deterministic Utilities
#+begin_src lisp
(defmacro one-value (&body body)
  `(let (%result)
     (iter
       (while
        (catch 'fail
          (setf %result (progn ,@body))
          nil)))
     %result))
(defmacro fail () `(throw 'fail t))
(defmacro choice (&body clauses)
  (let ((norm (apply #'+ (mapcar #'car clauses)))
        (cdf 0.0))
    `(let ((%random-choice (random ,norm)))
       (cond ,@ (iter (for (prob . body) in clauses)
                  (for i from 0)
                  (incf cdf prob)
                  (collect `((< %random-choice ,cdf) ,@body)))
                (t (error "This is impossible."))))))
(defun choose-list (list)
  (if list
      (let ((i (random (length list))))
        (values (nth i list) i))
      (fail)))
#+end_src
*** Generate mutations
We apply the following rewrites recursively to every subterm in a given term:
- Construction :: Find a constructor/library function whose return type is the type of current subterm, fill in arguments using ~default-term~ or the current subterm.
- Variable :: Replace the current subterm with a tryable value of the same type.
- Projection :: If the current subterm is an application, replace the current subterm with one of its argument of the same type, if any.

#+begin_src lisp
(defun replace-nth (list i elem)
  (declare (type fixnum i))
  (if (> i 0)
      (cons (car list) (replace-nth (cdr list) (1- i) elem))
      (cons elem (cdr list))))
(defun generate-mutation (term hole)
  "Randomly generate a mutation of `term' for a given `hole'."
  (labels ((process (term type)
             (choice
              ;; Construction
               (0.1 (bind ((f (choose-list (library-functions type)))
                           (args (mapcar
                                  (lambda (arg-type)
                                    (if (equal arg-type type)
                                        term
                                        (default-term arg-type)))
                                  (arg-types f type))))
                      (cons f args)))
              ;; Variable
               (1.0 (bind (((:values tryable-type i) (choose-list (hole-tryable-types hole))))
                      (if (equal tryable-type type)
                          `(tryable ,i)
                          (fail))))
               ;; Projection
               (0.3
                (t:ematch term
                  ((list 'tryable _) (fail))
                  ((list* op args)
                   (bind (((:values arg i) (choose-list args))
                          (arg-type (nth i (arg-types op type))))
                     (if (equal arg-type type) arg (fail))))))
               ;; Subterm
               (3.0
                (t:ematch term
                  ((list 'tryable _) (fail))
                  ((list* op args)
                   (bind (((:values arg i) (choose-list args))
                          (arg-type (nth i (arg-types op type))))
                     (cons op (replace-nth args i (process arg arg-type))))))))))
    (process term (hole-type hole))))
#+end_src

It is observed that only a small number of generated mutations is used. Typically <5 out of 100~200 mutations. Therefore we don't generate the full set of mutations.
- Doing a true uniform sample out of the set of mutations without generating them will require computing the size of mutation sets at each choice point, which might be as costly as generating them.
- An alternative would be to do a random choice at each choice point. This will bias towards mutations near the root and the probability of descending into subterms decreases exponentially. This is what we currently do. Is this reasonable?

*** Size and edit distance metrics
We compile specialized versions of ~value-size-function~ and ~edit-distance-function~ for each type, because they have a big impact on performance. At runtime, ~edit-distance-function~ uses ~*edit-distance-memo*~ table to perform Dynamic Programming calculation of edit distance. The size of the table and any resizing will affect performance, so you should keep it as small as possible.
#+begin_src lisp
(defun term-size (term &aux (counter 0))
  (labels ((process (term)
             (incf counter)
             (when (compound-term-p term)
               (mapc #'process (cdr term)))))
    (process term)
    counter))
(progn
  (define-memo-function value-size-function (type)
    (compile-lambda
     `(lambda (value)
        (labels ((process (value)
                   (etypecase value
                     ,@(mapcar
                        (lambda (c)
                          `(,(constructor->cl-type c)
                            (+ ,(if (eq c (min-constructor type)) 0 1)
                               ,@(mapcar
                                  (lambda (accessor arg-type)
                                    (if (equal arg-type type)
                                        `(process (,accessor value))
                                        `(funcall (force ,(delay (value-size-function arg-type)))
                                                  (,accessor value))))
                                  (accessors c)
                                  (arg-types c type)))))
                        (constructors type)))))
          (process value)))))
  (setf (function-memo value-size-function nat) #'abs)
  #+nil (setf (function-memo value-size-function nat) (lambda (n) (if (= n 0) 0 1))))
(defun value-size (type value)
  (funcall (value-size-function type) value))
(defun make-edit-distance-memo ()
  (make-hash-table
   :test (lambda (x y)
           (and (eq (car x) (car y))
                (eq (cdr x) (cdr y))))
   :hash-function
   (lambda (x)
     (logxor (sb-impl::eq-hash (car x))
             (sb-impl::eq-hash (cdr x))))))
(defvar *edit-distance-memo* (make-edit-distance-memo)
  "Memoization table for edit distance calculation using dynamic programming.
Maps `(x . y)' to `(edit-distance type x y)', where `type' is reasonable (is this ok?).
It should be `clrhash'-ed regularly to avoid growth in size for performance reason.")
(progn
  (define-memo-function edit-distance-function (type)
    (compile-lambda
     `(lambda (value-1 value-2)
        (labels ((one-side (value-1 value-2)
                   (etypecase value-1
                     ,@(mapcar
                        (lambda (c)
                          `(,(constructor->cl-type c)
                            (min ,@
                             (s:filter-map
                              (lambda (accessor arg-type)
                                (when (equal arg-type type)
                                  `(1+ (process (,accessor value-1)
                                                value-2))))
                              (accessors c)
                              (arg-types c type))
                             (+ (if (equal value-1 ',(default-value type))
                                    0 1)
                                (funcall ,(value-size-function type) value-2)))))
                        (constructors type))))
                 (process (value-1 value-2)
                   (ensure-gethash
                    (cons value-1 value-2) *edit-distance-memo*
                    (min
                     (one-side value-1 value-2)
                     (one-side value-2 value-1)
                     (etypecase value-1
                       ,@(mapcar
                          (lambda (c)
                            `(,(constructor->cl-type c)
                              (if (typep value-2 ',(constructor->cl-type c))
                                  (+ ,@
                                   (mapcar
                                    (lambda (accessor arg-type)
                                      (if (equal arg-type type)
                                          `(process (,accessor value-1)
                                                    (,accessor value-2))
                                          `(funcall (force ,(delay (edit-distance-function arg-type)))
                                                    (,accessor value-1)
                                                    (,accessor value-2))))
                                    (accessors c)
                                    (arg-types c type)))
                                  1000)))
                          (constructors type)))))))
          (process value-1 value-2)))))
  (setf (function-memo edit-distance-function nat)
              (lambda (x y) (abs (- x y))))
  #+nil (setf (function-memo edit-distance-function nat)
        (lambda (x y) (if (= x y) 0 1))))
(defun edit-distance (type value-1 value-2)
  (funcall (edit-distance-function type) value-1 value-2))
#+end_src

** Search algorithm
*** Ultility numerical functions
#+begin_src lisp
(defvar *beta* 5.0)
(locally
    (declare (optimize (speed 3)))
  (defsubst fastlog2 (p)
    "Compute `log2(p)' approximately for *positive* integer `p'."
    (declare (type fixnum p))
    (let* ((exponent (1- (integer-length p)))
           (x (scale-float (coerce p 'single-float) (- exponent))))
      (declare (type single-float x))
      (+ exponent (- (* -0.4326728 x (- x 5.261706)) 1.8439242))))
  (defun accept-p (cost-2 cost-1)
    (declare (type single-float cost-2 cost-1 *beta*))
    (or (< cost-2 cost-1)
        (< (+ (fastlog2 (1+ (random 1000))) (* *beta* (- cost-2 cost-1)))
           (fastlog2 (1+ 1000))))))
#+end_src

*** Generic random search procedure
#+begin_src lisp
(defvar *search-procedure* 'mcmc-search)
(defvar *restart* 500000)
#+end_src

The following perform one single trace of MCMC search, stopping after =*restart*= proposals (and returning =nil= if it stops without finding a solution). Users are expected to have some driver loop that calls it repeatedly until success.

The conventional return values for search-related procedures are =(values correct-p par cost)=.

#+begin_src lisp
(defvar *max-stuck-iterations* 20)
(defvar *accept-p* 'accept-p)
(defvar *seed* 0)
(defun mcmc-search (par mutate cost)
  (bind ((seed (or *seed* (random most-positive-fixnum)))
         (*random-state* (sb-ext:seed-random-state seed))
         (n 0)
         (*edit-distance-memo* (make-edit-distance-memo))
         (par-1 par)
         (cost-1 (funcall cost par))
         (stuck-iterations 0)
         (solved-p))
    (vom:info "MCMC w/seed ~a started, cost ~a." seed cost-1)
    (iter
      (while (< n *restart*))
      (incf n)
      (for candidate = (funcall mutate par-1))
      (for (values cost-2 correct-p) = (funcall cost candidate))
      (when correct-p
        (setq solved-p t)
        (return))
      (if (funcall *accept-p* cost-2 cost-1)
          (psetf cost-1 cost-2 par-1 candidate
                 stuck-iterations 0)
          (progn
            (incf stuck-iterations)
            (when (>= stuck-iterations *max-stuck-iterations*)
              (vom:info "Stuck on one candidate for ~a iterations, give up."
                        stuck-iterations)
              (return))))
      (finally-protected
       #-aws-lambda (print par-1)
       (vom:info "Search w/seed ~a stopped, ~a accepted proposals, cost ~a."
                 seed n cost-1)))
    (values solved-p par-1 cost-1)))
#+end_src

#+begin_src lisp
(defun greedy-search (par mutate cost)
  (let ((*accept-p* #'<))
    (mcmc-search par mutate cost)))
#+end_src

*** The synthesizer
#+begin_src lisp
(defun skeleton-cost-error (skeleton examples par)
  (catch 'cost
    (let ((functions (skeleton-functions skeleton par)))
      (iter (for (input output) in examples)
        (for output-1 =
             (with-resource-limit
               (handler-case
                   (apply (lastcar functions) input)
                 (error (c)
                   (abort-evaluation (class-name (class-of c)))))))
        (clrhash *edit-distance-memo*)
        (sum (fastlog2
              (the fixnum
                   (1+ (edit-distance
                        (return-type (skeleton-type skeleton))
                        output output-1)))))))))
(defun skeleton-cost-norm (par)
  (fastlog2
   (the fixnum
        (1+ (reduce #'+ par :key #'term-size)))))
(defun skeleton-cost (skeleton examples par)
  "Compute the cost given `examples' for the last function in `skeleton'.
`examples' are of the form `(((input ...) expected-output) ...)'.
Returns two values: the numerical cost and whether the solution is found."
  (let ((cost-error (skeleton-cost-error skeleton examples par)))
    (values (+ cost-error (skeleton-cost-norm par))
            (zerop cost-error))))
#+end_src

The following perform one single trace of search ( using =*search-procedure*=). It returns =nil= if it stops without finding a solution. Users are expected to have some driver loop that calls it repeatedly until success. It's also useful for observing behavior of a single search trace.
#+begin_src lisp
(defvar *initial-par* nil)
(defvar *frozen-holes* nil)
(defun resolve-variable (symbol-or-object)
  (if (symbolp symbol-or-object)
      (eval symbol-or-object)
      symbol-or-object))
(defun solve-skeleton-one-try (skeleton examples library-functions)
  (psetq skeleton (resolve-variable skeleton)
         examples (resolve-variable examples)
         library-functions (resolve-variable library-functions))
  (let ((*library-table* (make-hash-table :test 'equal))
        (mutable-hole-alist
          (iter (for i from 0)
            (for h in (skeleton-holes skeleton))
            (unless (member i *frozen-holes*)
              (collect (cons h i))))))
    (labels ((mutate (par)
               (one-value
                 (bind (((hole . i) (choose-list mutable-hole-alist)))
                   (replace-nth par i (generate-mutation (nth i par) hole)))))
             (cost (par)
               (skeleton-cost skeleton examples par)))
      (mapc
       (lambda (entry) (apply #'add-library-function entry))
       library-functions)
      (funcall *search-procedure*
               (or *initial-par*
                   (mapcar (compose #'default-term #'hole-type) (skeleton-holes skeleton)))
               #'mutate #'cost))))
#+end_src

#+begin_src lisp :load no
(defun progressive-solve-skeleton-one-try (skeleton examples library-functions)
  (let (*initial-par*)
    (iter (for i below (length examples))
      (for (values correct-p par cost) =
           (solve-skeleton-one-try skeleton (subseq examples 0 (1+ i)) library-functions))
      (vom:info "Search with ~a examples complete." i)
      (setq *initial-par* par)
      (unless correct-p (return (values nil par cost))) ;; TODO: more sensible cost?
      (finally (return (values t par cost))))))
#+end_src

*** Parallel implementation
#+begin_src lisp
(defvar *context-vars*
  '(*beta* *search-procedure* *restart* *max-stuck-iterations* *seed*
    *frozen-holes* *initial-par* *eval-toplevel*))
(defvar *context-vars-default-values*
  (iter (for s in *context-vars*) (collect (symbol-value s))))
(defun capture-context-vars ()
  (iter
    (for s in *context-vars*)
    (for v in *context-vars-default-values*)
    (unless (equalp (symbol-value s) v)
      (collect s into vars)
      (collect (symbol-value s) into values))
    (finally (return (values vars values)))))

(defun parallel-search (&rest thunks)
  "Interleave search `thunks' in parallel.
Each thunk is called with no argument, and can return any number of values.
The first value must be `correct-p', which stops the search if it ever becomes true.
All return values from the search that succeeds are returned verbatim."
  (unwind-protect
       (let ((channel (lparallel:make-channel))
             (lparallel:*task-category* 'parallel-search)
             (*seed* (or *seed* (random most-positive-fixnum)))
             (n-concurrency (ceiling (lparallel:kernel-worker-count) (length thunks))))
         (vom:info "Releasing the swarm with initial seed ~a." *seed*)
         (iter (for _ below n-concurrency)
           (iter (for thunk in thunks)
             (lparallel:submit-task
              channel
              (bind (((:values context-vars context-vals)
                      (capture-context-vars)))
                (lambda ()
                  (progv context-vars context-vals
                    (cons thunk (multiple-value-list (funcall thunk))))))))
           (incf *seed*))
         (iter
           (for (thunk correct-p . rest) = (lparallel:receive-result channel))
           (when correct-p (return (values-list (cons correct-p rest))))
           (lparallel:submit-task
            channel
            (bind (((:values context-vars context-vals)
                    (capture-context-vars)))
              (lambda ()
                (progv context-vars context-vals
                  (list thunk (funcall thunk))))))
           (incf *seed*)))
    (lparallel:kill-tasks 'parallel-search)))
#+end_src

#+begin_src lisp
(defvar *solve-skeleton-procedure* 'parallel-solve-skeleton)
(defun solve-skeleton (skeleton examples library-functions)
  (funcall *solve-skeleton-procedure* skeleton examples library-functions))
(defun parallel-solve-skeleton (skeleton examples library-functions)
  (parallel-search
   (lambda ()
     (solve-skeleton-one-try skeleton examples library-functions))))
#+end_src

*** AWS Lambda Backend
**** AWS Lambda Worker Function
#+begin_src lisp
(defun assoc-string (alist key)
  (assoc-value alist key :test #'string=))
(defun aws-lambda-handler (event)
  "Handle AWS Lambda `event'. Runs on AWS Lambda worker instances."
  (handler-case
      (with-standard-io-syntax
        (bind ((*print-circle* t)
               (body (assoc-string event "body")))
          (list (cons "result"
                      (prin1-to-string
                       (multiple-value-list (eval (read-from-string body))))))))
    (error (c)
      (vom:error "Error handling event ~s: ~a" event c)
      (list (cons "error" (format nil "~a" c))))))
#+end_src

**** Deploying AWS Lambda Worker Function
The following builds and packages an AWS Lambda custom runtime =function.zip= using a Docker image named =cl-lambda-builder=. You must run =build-aws-lambda-builder= at least once before using any other procedures to build the =cl-lambda-builder= Docker image.

Note that we use =invoke-aws-lambda= to send S-expression to AWS Lambda, which has a certain level of flexibility, so that you don't necessarily need to rerun =deploy-aws-lambda= after every changes. E.g.:
- If you just changed some parameters (e.g. =*beta*=, or any variables in =*context-vars*=), there's no need to redeploy.
- If you defined a new example set, you can either
  - Pass in the example set as a literal list, no need to redeploy.
  - Pass in the example set as a variable symbol, in this case you have to rerun =deploy-aws-lambda= to make the variable defined on workers. This saves some bandwidth by not sending the full example set in the HTTP requests.
- If you defined a new skeleton, you can either
  - Pass in the skeleton a literal skeleton (which serializes to =#.(with-skeleton ...)=), no need to redeploy. However, the same skeleton definition will have to be compiled once on each worker instance. Depending on the size of the skeleton, this may waste substantial time and compute power.
  - (Recommended) Pass in the skeleton as a variable symbol. In this case you have to rerun =deploy-aws-lambda=. The skeleton will be compiled only once on your local machine. This also saves some bandwidth by not sending the full skeleton definition in the HTTP requests.

#+begin_src lisp
(defun cmd (&rest args)
  (uiop:run-program args :output t :error-output t))
(defun build-aws-lambda-builder ()
  (cmd "docker" "build" "./" "-t" "cl-lambda-builder"))
(defun build-aws-lambda-image ()
  (handler-case (cmd "docker" "image" "inspect" "cl-lambda-builder")
    (uiop:subprocess-error ()
      (vom:info "Docker image cl-lambda-builder not found, build it.")
      (build-aws-lambda-builder)))
  (cmd "docker" "volume" "create" "cl-aws-asdf-cache")
  (cmd "docker" "volume" "create" "cl-aws-quicklisp")
  (cmd "docker" "run" "--rm"
       "-e" "ASDF_OUTPUT_TRANSLATIONS=\"/:/asdf-cache/\""
       "-e" "LAMBDA_SYSTEM_NAME=genrec/aws-lambda"
       "-v" "./:/work/:Z"
       "-v" "cl-aws-quicklisp:/root/quicklisp"
       "-v"  (s:concat (uiop:native-namestring #P"~/quicklisp/local-projects")
                       ":/root/quicklisp/local-projects:Z")
       "-v" "cl-aws-asdf-cache:/asdf-cache/"
       "cl-lambda-builder"))
(defun deploy-aws-lambda ()
  (build-aws-lambda-image)
  (cmd "aws" "lambda" "update-function-code"
       "--function-name" "genrec-kernel"
       "--zip-file" "fileb://function.zip"))
#+end_src

**** Invoking AWS Lambda Worker Functions
#+begin_src lisp
(defvar *ssl-ctx* nil)
#-aws-lambda
(defun invoke-aws-lambda (form)
  "Evaluate `form' on a AWS Lambda worker.
Returns a `blackbird:promise' that resolves to evaluation result."
  (with-standard-io-syntax
    (let ((*print-circle* t))
      (alet ((response
              (carrier:request
               "https://jggef6y3vjkjcrbfqzexuwoure0amokc.lambda-url.us-west-1.on.aws/"
               :method :post
               :headers '(:content-type "text/plain")
               :body (prin1-to-string form)
               :return-body t
               :ssl-ctx *ssl-ctx*)))
        (bind ((alist (jonathan:parse (babel:octets-to-string response) :as :alist))
               (result (assoc-string alist "result")))
          (if result
              (values-list (read-from-string result))
              (error "Remote error: ~a" (assoc-string alist "error"))))))))
#+end_src

**** Search Procedure
#+begin_src lisp
(defvar *search-launched* nil)
(defvar *search-completed* nil)
(defvar *search-failed* nil)
(defvar *status-vars* '(*search-launched* *search-completed* *search-failed*))
(defvar *report-daemon-thread* nil)
(defun symbol-label (s)
  (setq s (string-downcase (string-trim "*" s)))
  (cl-ppcre:regex-replace-all "-" s " "))
(defun report-daemon ()
  (let ((last-reported (mapcar #'symbol-value *status-vars*)))
    (loop
      (sleep 1.0)
      (unless (equal last-reported (mapcar #'symbol-value *status-vars*))
        (setq last-reported (mapcar #'symbol-value *status-vars*))
        (vom:info "~{~{~a ~a~}~^, ~}"
                  (iter (for s in *status-vars*)
                    (collect `(,(symbol-label s) ,(symbol-value s)))))))))
(defun ensure-report-daemon ()
  (unless (and *report-daemon-thread*
               (bt:thread-alive-p *report-daemon-thread*))
    (setq *report-daemon-thread*
          (bt:make-thread #'report-daemon :name "Status Report"))))
(defvar *n-aws-workers* 256)
#-aws-lambda
(setq *solve-skeleton-procedure* 'aws-lambda-solve-skeleton)
#-aws-lambda
(defun aws-lambda-solve-skeleton (skeleton examples library-functions)
  (declare (optimize (debug 3)))
  (bind (result
         (pars (make-hash-table))
         (counts (make-hash-table)))
    (vom:info "Releasing the swarm with initial seed ~a." *seed*)
    (setq *search-launched* 0 *search-completed* 0 *search-failed* 0)
    (ensure-report-daemon)
    (labels ((do-search (seed next-seed)
               (unless result
                 (incf *search-launched*)
                 (bind ((*seed* next-seed)
                        (*initial-par* (gethash seed pars))
                        #+nil (initial-par *initial-par*)
                        ((:values context-vars context-vals) (capture-context-vars))
                        (form `(progv ',context-vars ,(uneval context-vals)
                                 (values-list
                                  (cons (random most-positive-fixnum)
                                        (multiple-value-list
                                         (solve-skeleton-one-try
                                          ',skeleton ',examples ',library-functions)))))))
                   (catcher
                    (blackbird:multiple-promise-bind
                        (next-seed correct-p par cost) (invoke-aws-lambda form)
                      (declare (ignore cost))
                      #+nil (print (list form initial-par par))
                      (incf *search-completed*)
                      (when correct-p
                        (vom:info "Search ~a succeeded" seed)
                        (setq result par))
                      (setf (gethash seed pars) par
                            (gethash seed counts) (1+ (or (gethash seed counts) 0)))
                      (do-search #+nil (+ seed *n-aws-workers*)
                        seed next-seed))
                    (error (c)
                           (incf *search-failed*)
                           (vom:error "Search ~a failed: ~a" seed c)))))))
      (let ((*ssl-ctx* (cl-async-ssl::create-ssl-ctx)))
        (unwind-protect
             (progn
               (cl-async-ssl::ssl-ctx-set-default-verify-paths *ssl-ctx*)
               (as:with-event-loop ()
                 (iter (for i below *n-aws-workers*)
                   (do-search i (+ i 256)))))
          (cl-async-ssl::ssl-ctx-free *ssl-ctx*))))
    result))
#+end_src

** Stratified Synthesis
#+begin_src lisp
(defun compute-live-holes (skeleton examples par)
  (let ((compiled-par (compile-par par (skeleton-lazy-evaluation-p skeleton)))
        (live-holes))
    (iter (for i index-of-vector compiled-par)
      (setf (aref compiled-par i)
            (let ((orig-func (aref compiled-par i))
                  (my-index i))
              (lambda (mem)
                (pushnew my-index live-holes)
                (funcall orig-func mem)))))
    (let ((functions (funcall (skeleton-generator skeleton) compiled-par)))
      (iter (for (input) in examples)
        (with-resource-limit
          (apply (lastcar functions) input))))
    live-holes))
(defun live-functions (skeleton examples par)
  (let (result)
    (iter (for i in (compute-live-holes skeleton examples par))
      (pushnew (hole-function (nth i (skeleton-holes skeleton))) result))
    result))
(defun holes-for-functions (skeleton function-indices)
  (iter (for i from 0)
    (for hole in (skeleton-holes skeleton))
    (when (member (hole-function hole) function-indices)
      (collect i))))
#+end_src

#+begin_src lisp
(defun stratified-solve (skeleton examples-list library-functions disabled-functions-list)
  (let (*initial-par* *frozen-holes*)
    (iter (for examples in examples-list)
      (for disabled-functions in disabled-functions-list)
      (for disabled-holes = (holes-for-functions (resolve-variable skeleton) disabled-functions))
      (for i from 0)
      (setq *frozen-holes* (union *frozen-holes* disabled-holes))
      (for par = (solve-skeleton skeleton examples library-functions))
      (print par)
      (setq *initial-par* par
            *frozen-holes* (set-difference
                            (compute-live-holes
                             (resolve-variable skeleton)
                             (resolve-variable examples)
                             par)
                            disabled-holes))
      (vom:info "Example set #~a solved, ~a holes frozen." i (length *frozen-holes*)))
    *initial-par*))
#+end_src

** Profiling and Debugging
#+begin_src lisp
(defun call-with-advices (names advices thunk)
  (mapcar
   (lambda (name advice)
     (sb-int:encapsulate name 'profiling advice))
   names advices)
  (unwind-protect (funcall thunk)
    (mapcar
     (lambda (name) (sb-int:unencapsulate name 'profiling))
     names)))
(defmacro with-advices (name-and-advices &body body)
  `(call-with-advices
    ',(mapcar #'car name-and-advices)
    (list ,@(mapcar #'cadr name-and-advices))
    (lambda () ,@body)))
(defun call-with-profiling (thunk)
  (let (error-alist
        (programs 0)
        (evaluations 0)
        (accepted-programs 0)
        (time-start (get-internal-real-time)))
    (vom:info "Profiling started")
    (unwind-protect
         (with-advices
             ((abort-evaluation
               (lambda (orig reason)
                 (setf (assoc-value error-alist reason)
                       (1+ (or (assoc-value error-alist reason) 0)))
                 (funcall orig reason)))
              (skeleton-cost
               (lambda (orig &rest args)
                 (incf programs)
                 (incf evaluations (length (cadr args)))
                 (apply orig args)))
              (accept-p
               (lambda (orig &rest args)
                 (when (apply orig args)
                   (incf accepted-programs)
                   t))))
           (funcall thunk))
      (let ((time (/ (- (get-internal-real-time) time-start)
                     internal-time-units-per-second)))
        (vom:info "Profiling ended.
~4t~a programs, ~a accepted, ~a evaluations, ~a evaluation errors;
~4t~,3f s real time, ~,1f prog/s, ~,1f eval/s;
~4tError breakdown: ~a"
                  programs accepted-programs evaluations (reduce #'+ error-alist :key #'cdr)
                  time (/ programs time) (/ evaluations time)
                  error-alist)))))
(defmacro with-profiling (&body body)
  `(call-with-profiling (lambda () ,@body)))
#+end_src

** Test Generation
#+begin_src lisp
(defun sample (type)
  (let ((op (nth (random (length (constructors type)))
                 (constructors type))))
    (if (fboundp op)
        (apply op (mapcar #'sample (arg-types op type)))
        op)))
(defun samples (type n &optional (size 50))
  (let (results)
    (iter (while (< (length results) n))
      (let ((sample (sample type)))
        (when (< (value-size type sample) size)
          (pushnew sample results :test #'equal))))
    (sort results #'< :key (value-size-function type))))
(defun generate-examples
    (symbol n &optional (output-size (get symbol :output-size 200)))
  (bind (((:plist type) (symbol-plist symbol))
         ((_ argument-types result-type) type)
         (argument-type `(tuple ,@argument-types)))
    (let (results)
      (iter (for _ below 1000)
        (while (< (length results) n))
        (bind ((inputs (sample argument-type)))
          (when (< (value-size argument-type inputs) 30)
            (bind ((output (apply symbol inputs)))
              (when (< (value-size result-type output) output-size)
                (pushnew (list inputs output) results :test #'equal))))))
      (sort results #'<
            :key (lambda (r) (value-size argument-type (car r)))))))
(defun test-solution (tests skeleton par)
  (handler-case
      (sb-ext:with-timeout 1
        (iter (for (inputs output) in tests)
          (accumulate
           (equal (apply #'call-skeleton skeleton par inputs)
                  output)
           by #'and initial-value t)))
    (t ())))
#+end_src

** Built-in Types
Although weak in theoretical sense, our type facility allow us to easily exploit efficient representations besides standard ADT representation (tagged union implemented by CL struct).
#+begin_src lisp
(deftype list-of (element-type) (declare (ignore element-type)) t)
(deftype nat () '(and fixnum (integer 0)))
#+end_src

We use native Lisp conses to represent ~list-of *~.
#+begin_src lisp
(setf (constructors 'list-of) '(cons nil)
      (get 'cons 'arg-types) (t:lambda-ematch1 (list 'list-of x)
                               `(,x (list-of ,x)))
      (get 'cons 'accessors) '(car cdr)

      (get 'nil 'arg-types) nil
      (get 'nil 'accessors) nil
      (get 'nil 'cl-type) 'null)
#+end_src

We use machine numbers rather than unary ADT representation to represent ~nat~. Huge performance gain!
#+begin_src lisp
(defun succ (x) (1+ x))
(defun zero () 0)

(setf (constructors 'nat) '(zero succ)
      (get 'zero 'arg-types) nil
      (get 'zero 'accessors) nil
      (get 'zero 'cl-type) '(integer 0 0)
      (get 'succ 'arg-types) '(nat)
      (get 'succ 'accessors) '(1-)
      (get 'succ 'cl-type) '(and fixnum (integer 1))
      (get '+ 'arg-types) '(nat nat))
#+end_src

Tuple type. Currently support up to 16 fields.
#+begin_src lisp
(setf (constructors 'tuple) '(list)
      (get 'list 'arg-types) (t:lambda-ematch1 (list* 'tuple arg-types)
                               arg-types)
      (get 'list 'accessors) (map-iota
                              (lambda (i) `(lambda (x) (nth ,i x)))
                              16))
#+end_src

We could have defined ~boolean~ with ~define-adt~, but ~boolean~ is a symbol from standard CL and ~define-adt~ expands into a somewhat problematic redefinition ~(deftype boolean ...)~ (which triggers [[https://www.sbcl.org/manual/#Package-Locks][Package Locks]] on SBCL). Therefore, we use the low level interface.
#+begin_src lisp
(setf (constructors 'boolean) '(nil t)
      (get 't 'arg-types) nil)
#+end_src

** Convenience
#+begin_src lisp
(defun call-skeleton (skeleton par &rest args)
  (with-resource-limit
    (let* ((par (or par (mapcar (compose #'default-term #'hole-type) (skeleton-holes skeleton))))
           (functions (skeleton-functions skeleton par)))
      (apply (lastcar functions) args))))
(defvar *problems* nil)
(defmacro defproblem (name argument-types result-type args &body body)
  `(progn
     (export '(,name))
     (pushnew ',name *problems*)
     (setf (get ',name :type) '(function ,argument-types ,result-type))
     (defun ,name ,args ,@body)))
(defmacro inputs-to-examples (reference &body inputs)
  `(list
    ,@ (mapcar (lambda (input) `(list (list ,@input) (,reference ,@input))) inputs)))
#+end_src

* Emacs Support
** Notes
~literate-lisp~ with ~poly-org~ is super cool, but as of time of writing (<2023-02-06 Mon>) they're still a bit buggy.
- Manually entering =#+begin_src= and =#+end_src= (e.g. to split a source block into two) may break ~poly-org~.
  To be safe, use shortcut =< s TAB= to make a new source block and copy code into it. Note that this short cut is available only after =org-tempo= is loaded, either from your =init.el= or =M-: (require 'org-tempo)= manually.
- Sometimes ~poly-org~ does not fontify correctly, and =s-u= (~revert-buffer~) won't save it.
  ~kill-buffer~ then reopen usually fixes it. Also, ~s-u~ work differently when inside/outside a code block.

Various ~org~ niceties interact with ~poly-org~ setup nicely or badly. Here are some tested:
#+ATTR_HTML: :style list-style:none
#+ATTR_LATEX: :options [label={}]
- \check =visual-line-mode=
- \check =org-variable-pitch-minor-mode=
- \times =org-appear-mode= does not re-fontify when cursor move out of revealed element.
- \check =org-superstar-mode=
- =org-indent-mode= breaks fontification (syntax highlighting) in code blocks.
  - QH made a PR to fix it [[https://github.com/polymode/poly-org/pull/45]]
- \check ~(setq org-pretty-entities t)~
- ~lsp-mode~ (I would like to use ~lsp-ltex~)
  Running ~lsp~ or ~lsp-deferred~ in buffer init hook makes it unusable (cursor jump to end of buffer after every change). However, openning the buffer without ~lsp~ then ~M-x lsp~ seems to work fine.
- \times ~topsy-mode~
** COMMENT Custom Export Filters
If you'd like to render result-quality HTML or PDF, run the following or add them to your ~init.el~.
~genrec-export-filter-parse-tree-function~ does the following
- Scan for code blocks followed by result blocks, and add \LaTeX{} wrappers to group them in one ~tcolorbox~ environment.
#+begin_src emacs-lisp :results none
(require 'cl)
(require 'org-element)

(defun genrec-export-filter-parse-tree-function (data b c)
  (when (eq b 'latex)
    (org-element-map data '(src-block headline)
      (lambda (src)
        (let* ((parent (org-element-property :parent src))
               (siblings (org-element-contents parent))
               (pos (cl-position src siblings)))
          (when pos ;; We modify parse tree destructively and need to guard against orphan nodes.
            (let* ((nextpos (1+ pos))
                   (next (nth nextpos siblings)))
              (cl-flet ((make-latex (v)
                          (org-element-create 'latex-fragment
                                              (list :value v :parent parent))))
                (cond ((and (eq (org-element-type src) 'src-block)
                            (org-element-property :results next))
                       (let (result-blocks)
                         (while (and next (org-element-property :results next))
                           (push next result-blocks)
                           (setq nextpos (1+ nextpos))
                           (setq next (nth nextpos siblings)))
                         (when result-blocks
                           (apply #'org-element-set-contents
                                  parent
                                  (append
                                   (cl-subseq siblings 0 pos)
                                   (list
                                    (make-latex "\\begin{Example}[]\\fvset{xleftmargin=0cm}")
                                    src
                                    (make-latex "\\tcblower\\fvset{xleftmargin=0cm}"))
                                   result-blocks
                                   (list (make-latex "\\end{Example}"))
                                   (cl-subseq siblings nextpos))))))
                      ((and (eq (org-element-type src) 'headline)
                            (org-element-property :todo-type src))
                       (while (and next (eq (org-element-type next) 'headline)
                                   (org-element-property :todo-type next))
                         (apply #'org-element-adopt-elements src
                                (apply #'org-element-create 'paragraph (list :parent src)
                                       (org-element-property :title next))
                                (org-element-contents next))
                         (setq nextpos (1+ nextpos))
                         (setq next (nth nextpos siblings)))
                       (apply #'org-element-set-contents
                              parent
                              (append
                               (cl-subseq siblings 0 pos)
                               (list (make-latex "\\mymarginpar{")
                                     (apply #'org-element-create 'paragraph (list :parent parent)
                                            (org-element-property :title src))
                                     (make-latex "\n"))
                               (org-element-contents src)
                               (list (make-latex "}"))
                               (cl-subseq siblings nextpos))))))))
          src))))
  data)
(add-hook 'org-export-filter-parse-tree-functions #'genrec-export-filter-parse-tree-function)
#+end_src

#+begin_src emacs-lisp :results none
(require 'engrave-faces-latex)
(define-advice engrave-faces-latex-face-mapper (:around (orig faces content) genrec)
  (if (if (listp faces) (member 'font-lock-doc-face faces)
        (eq faces 'font-lock-doc-face))
      (concat (when (eq (aref content 0) ?\")
                "\\margindoc{")
              (replace-regexp-in-string
               "'\\([^[:alnum:]]\\)\\|'$" "}\\1"
               (replace-regexp-in-string
                "`" "{\\\\ttfamily{}"
                (string-trim content "\"" "\"")))
              (when (eq (aref content (1- (length content))) ?\")
                "}"))
    (funcall orig faces content)))
(defun genrec-org-export-filter-final-output-function (data b c)
  (when (eq b 'latex)
    (with-temp-buffer
      (insert data)
      (goto-char (point-min))
      (while (search-forward "\\margindoc" nil t)
        (save-excursion
          (goto-char (- (point) (length "\\margindoc")))
          (let ((end (point)))
            (skip-chars-backward " \t\n\r")
            (delete-region (point) end)))
        (save-excursion
          (let ((beg (- (point) (length "\\margindoc"))))
            (forward-sexp)
            (let ((end (point)))
              (end-of-line)
              (transpose-regions beg end end (point))))))
      (setq data (buffer-string))))
  data)
(add-to-list 'org-export-filter-final-output-functions
             'genrec-org-export-filter-final-output-function)

(setq-default engrave-faces-themes
              '((default
                 (default :short "default" :slug "D" :foreground "#000000" :background "#ffffff")
                 (shadow :short "shadow" :slug "h" :foreground "#A1ACC2")
                 (success :short "success" :slug "sc" :foreground "#228b22" :weight bold)
                 (error :short "error" :slug "e" :foreground "#A8723E" :weight bold)
                 (font-lock-comment-face :slug "c" :foreground "#A1ACC2" :slant normal)
                 (font-lock-comment-delimiter-face :slug "cd" :foreground "#A1ACC2")
                 (font-lock-string-face :slug "s")
                 (font-lock-doc-face :slug "d")
                 (font-lock-keyword-face :slug "k" :foreground "#1D4A8D")
                 (font-lock-builtin-face :slug "b" :foreground "#1D4A8D")
                 (font-lock-function-name-face :slug "f")
                 (font-lock-doc-markup-face :slug "m")
                 (font-lock-variable-name-face :slug "v")
                 (font-lock-type-face :slug "t")
                 (font-lock-constant-face :slug "o")
                 (font-lock-warning-face :slug "wr" :foreground "#A8723E")
                 (org-block :short "org-block" :slug "ob"))))
(setq-default org-latex-src-block-backend 'engraved)
(engrave-faces-use-theme 'default)

(setq org-latex-engraved-preamble "\\usepackage{fvextra}

[FVEXTRA-SETUP]

% Make line numbers smaller and grey.
\\renewcommand\\theFancyVerbLine{\\footnotesize\\color{black!40!white}\\arabic{FancyVerbLine}}

\\usepackage{xcolor}

% In case engrave-faces-latex-gen-preamble has not been run.
\\providecolor{EfD}{HTML}{f7f7f7}
\\providecolor{EFD}{HTML}{28292e}

[LISTINGS-SETUP]")

(setq org-latex-engraved-options
      '(("fontsize" . "\\small")
        ("xleftmargin" . "\\parindent")
        ("commandchars" . "\\\\\\{\\}")
        ("breaklines" . "true")
        ("breaksymbol" . "\\color{skyshy}\\tiny\\ensuremath{\\hookrightarrow}")))

(setq org-latex-hyperref-template "\\hypersetup{
 colorlinks=true,
 linkcolor=black,
 urlcolor=EFk,
 pdfauthor={%a},
 pdftitle={%t},
 pdfkeywords={%k},
 pdfsubject={%d},
 pdfcreator={%c},
 pdflang={%L}}
")

(set-alist 'org-latex-classes
           "genrec-book"
           '("\\documentclass[a4paper]{memoir}"
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+end_src

** COMMENT Configurations
Disable leading indentation to ensure ~beginning-of-defun~ and ~end-of-defun~ works properly. This ensures important SLIME functions (e.g. ~slime-compile-defun~) work properly.

# Local Variables:
# org-edit-src-content-indentation: 0
# org-adapt-indentation: nil
# org-export-use-babel: nil
# org-hide-emphasis-markers: nil
# org-link-abbrev-alist: (("wiki" . "https://en.wikipedia.org/wiki/"))
# org-html-htmlize-output-type: css
# End:
