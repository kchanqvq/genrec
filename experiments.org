# -*- Mode: POLY-ORG ;-*- ---
#+TITLE: GENREC
#+AUTHOR: QH
* Experiments
** Natural Numbers
*** Multiplication
#+begin_src lisp
(uiop:define-package #:genrec/experiments/nat
    (:mix #:cl #:genrec #:serapeum))
(in-package #:genrec/experiments/nat)
(defproblem nat-mul (fixnum fixnum) fixnum
  (a b) (* a b))
#+end_src

#+begin_src lisp :load no
(def nat-skeleton
  (para-skeleton
   (function (nat nat) nat)
   nat nat nat))
(def nat-skeleton
  (fully-connected-skeleton
   (function (nat nat) nat)
   (function (nat nat) nat)))
(def nat-examples
  '(((0 0) 0) ((1 0) 0) ((0 1) 0) ((2 0) 0) ((1 1) 1) ((0 2) 0) ((0 3) 0) ((2 1) 2) ((3 0) 0) ((2 2) 4) ((0 4) 0) ((1 3) 3) ((3 1) 3) ((5 2) 10) ((2 5) 10) ((8 0) 0)))
(solve-skeleton nat-skeleton nat-examples '((zero nat) (succ nat)))
#+end_src

** Lambda Calculus (de Brujin index)
#+begin_src lisp
(uiop:define-package #:genrec/experiments/lc
    (:mix #:cl #:genrec #:serapeum))
(in-package #:genrec/experiments/lc)
(define-adt lc
  (var (index nat))
  (lam (body lc))
  (app (op lc) (arg lc)))
(define-adt lcv
  (clo (env (list-of lcv)) (body lc))
  (bot))
(defun safe-nth (n l)
  (let ((cons (nthcdr n l)))
    (if cons (car cons) 'bot)))
(setf (get 'safe-nth 'arg-types) (lambda (r) `(nat (list-of ,r))))
(defproblem lc-apply (lcv lcv) lcv
  (op arg)
  (etypecase op
    (clo (lc (clo-body op) (cons arg (clo-env op))))
    ((eql bot) 'bot)))
(defproblem lc (lc (list-of lcv)) lcv
  (lc env)
  (etypecase lc
    (var (safe-nth (var-index lc) env))
    (app (lc-apply (lc (app-op lc) env)
                   (lc (app-arg lc) env)))
    (lam (clo env (lam-body lc)))))
(def lc-examples
  (inputs-to-examples lc
    ((lam (var 0)) nil)
    ((lam (var 1)) nil)
    ((lam (var 0)) (list 'bot))
    ((lam (var 1)) (list 'bot))
    ((lam (var 1)) (list (clo nil (var 0))))
    ((var 0) (list (clo nil (var 0))))
    ((var 1) (list (clo nil (var 0))))
    ((lam (lam (var 0))) nil)
    ((app (lam (var 0)) (lam (var 0))) nil)
    ((app (var 0) (var 0)) nil)
    ((app (lam (var 0)) (var 0)) nil)
    ((app (var 0) (lam (var 0))) nil)
    ((app (app (lam (lam (var 0))) (lam (var 0))) (lam (var 0))) nil)
    ((app (app (lam (lam (var 0))) (lam (var 1))) (lam (var 0))) nil)
    ((app (app (lam (lam (var 0))) (lam (var 0))) (lam (var 1))) nil)
    ((app (lam (lam (var 0))) (lam (var 0))) nil)
    ((app (lam (lam (var 0))) (lam (var 1))) nil)
    ((app (lam (lam (var 1))) (lam (var 0))) nil)))
(def lc-skeleton
  (fully-connected-skeleton
   (function (lcv lcv) lcv)
   (function (lcv lc (list-of lcv)) lcv)
   (function (lc (list-of lcv)) lcv)))
(def lc-library '((clo lcv) (safe-nth lcv)
                  (cons (list-of lcv))))
#+end_src

The following experiments are run with =*restart*= is set to 1M proposals (which never happens), so that we can observe behavior of single uninterrupted search traces. It's run with a version of skeleton that does /not/ generate recursive calls for non-recursive dispatch cases. Later revision removed this restriction, that does not help in this case (in fact making it slower because it introduces more parameters), but is more general. All runs find the solution successfully, but with a wide distribution of run time and iterations (accepted proposals). The latter ranges from 4K to 500K.

#+begin_src lisp :load no :results output verbatim
(def lc-skeleton
  (fully-connected-skeleton
   (function (lcv lcv) lcv)
   (function (lc (list-of lcv)) lcv)))
(with-profiling
  (pprint
   (solve-skeleton-one-try lc-skeleton lc-examples
                           '((safe-nth lcv) (clo lcv) (cons (list-of lcv)))))
  (terpri))
#+end_src

#+RESULTS:
#+begin_example :load no
  <INFO> [11:52:55] genrec - Profiling started
  <INFO> [11:52:55] genrec - Search stopped, 4421 accepted proposals.

((TRYABLE 3) (TRYABLE 5) (TRYABLE 6) (TRYABLE 3)
 (CONS (CLO (NIL) (VAR (ZERO))) (TRYABLE 2)) (SAFE-NTH (ZERO) (NIL))
 (SAFE-NTH (ZERO) (NIL)) (TRYABLE 1) (CONS (TRYABLE 3) (TRYABLE 0))
 (SAFE-NTH (ZERO) (CONS (BOT) (CONS (CLO (NIL) (VAR (ZERO))) (NIL))))
 (SAFE-NTH (TRYABLE 0) (TRYABLE 2)) (CLO (TRYABLE 6) (TRYABLE 4)) (TRYABLE 1)
 (TRYABLE 0) (TRYABLE 3) (TRYABLE 4) (TRYABLE 0) (CLO (NIL) (VAR (ZERO)))
 (TRYABLE 0) (TRYABLE 2) (TRYABLE 0) (TRYABLE 0) (TRYABLE 2) (TRYABLE 2)
 (TRYABLE 5) (TRYABLE 0) (SAFE-NTH (ZERO) (NIL)) (TRYABLE 1) (TRYABLE 3))
  <INFO> [11:52:55] genrec - Profiling ended. 5348 programs, 4420 accepted, 96264 evaluations, 131 evaluation errors, 0.198 s real time, 26981.3 p/s, 485664.3 e/s.
#+end_example

#+RESULTS:
#+begin_example :load no
  <INFO> [11:52:10] genrec - Profiling started
  <INFO> [11:52:39] genrec - Search stopped, 501055 accepted proposals.

((TRYABLE 3) (TRYABLE 1) (TRYABLE 5) (TRYABLE 3) (TRYABLE 2) (TRYABLE 4)
 (TRYABLE 3) (TRYABLE 1) (CONS (TRYABLE 3) (TRYABLE 0)) (TRYABLE 0)
 (SAFE-NTH (TRYABLE 0) (TRYABLE 2)) (TRYABLE 0) (CLO (NIL) (VAR (ZERO)))
 (TRYABLE 1) (TRYABLE 3) (TRYABLE 4) (CLO (NIL) (VAR (ZERO)))
 (CLO (TRYABLE 3) (TRYABLE 1)) (TRYABLE 0) (TRYABLE 2) (TRYABLE 0) (TRYABLE 0)
 (TRYABLE 2) (TRYABLE 2) (TRYABLE 5) (SAFE-NTH (ZERO) (NIL))
 (CLO (CONS (BOT) (CONS (SAFE-NTH (ZERO) (CONS (BOT) (NIL))) (TRYABLE 4)))
      (TRYABLE 2))
 (TRYABLE 1) (TRYABLE 3))
  <INFO> [11:52:39] genrec - Profiling ended. 776265 programs, 501054 accepted, 13972770 evaluations, 33886 evaluation errors, 28.604 s real time, 27138.2 p/s, 488487.3 e/s.
#+end_example

#+RESULTS:
#+begin_example :load no
  <INFO> [11:51:56] genrec - Profiling started
  <INFO> [11:51:58] genrec - Search stopped, 36033 accepted proposals.

((TRYABLE 1) (TRYABLE 5) (TRYABLE 2) (TRYABLE 3) (CONS (TRYABLE 5) (TRYABLE 2))
 (CLO (TRYABLE 1) (VAR (ZERO))) (CLO (TRYABLE 1) (VAR (ZERO))) (TRYABLE 1)
 (TRYABLE 0) (SAFE-NTH (ZERO) (NIL)) (SAFE-NTH (TRYABLE 0) (TRYABLE 2))
 (TRYABLE 2) (CLO (NIL) (VAR (ZERO))) (SAFE-NTH (ZERO) (NIL)) (TRYABLE 2)
 (TRYABLE 4) (CLO (TRYABLE 3) (VAR (ZERO))) (CLO (TRYABLE 3) (TRYABLE 1))
 (TRYABLE 1) (TRYABLE 2) (TRYABLE 0) (TRYABLE 2) (TRYABLE 0) (TRYABLE 3)
 (TRYABLE 5) (CLO (CONS (BOT) (TRYABLE 4)) (TRYABLE 3)) (TRYABLE 0) (TRYABLE 0)
 (TRYABLE 3))
  <INFO> [11:51:58] genrec - Profiling ended. 49538 programs, 36032 accepted, 891684 evaluations, 2111 evaluation errors, 1.777 s real time, 27878.4 p/s, 501810.4 e/s.
#+end_example

#+RESULTS:
#+begin_example :load no
  <INFO> [11:51:32] genrec - Profiling started
  <INFO> [11:51:34] genrec - Search stopped, 34637 accepted proposals.

((TRYABLE 3) (SAFE-NTH (ZERO) (TRYABLE 3)) (TRYABLE 0) (TRYABLE 3) (TRYABLE 2)
 (TRYABLE 3) (TRYABLE 0) (TRYABLE 1) (CONS (TRYABLE 3) (TRYABLE 0)) (TRYABLE 0)
 (SAFE-NTH (TRYABLE 0) (TRYABLE 2)) (TRYABLE 2) (TRYABLE 2) (TRYABLE 1)
 (TRYABLE 2) (CONS (BOT) (TRYABLE 4)) (CLO (NIL) (VAR (ZERO)))
 (CLO (TRYABLE 3) (TRYABLE 1)) (TRYABLE 1) (TRYABLE 2) (TRYABLE 0) (TRYABLE 0)
 (TRYABLE 2) (TRYABLE 2) (TRYABLE 5) (TRYABLE 0) (TRYABLE 0) (TRYABLE 1)
 (TRYABLE 3))
  <INFO> [11:51:34] genrec - Profiling ended. 45056 programs, 34636 accepted, 811008 evaluations, 1627 evaluation errors, 1.642 s real time, 27443.6 p/s, 493984.2 e/s.
#+end_example

#+RESULTS:
#+begin_example :load no
  <INFO> [11:50:57] genrec - Profiling started
  <INFO> [11:50:59] genrec - Search stopped, 48035 accepted proposals.

((TRYABLE 1) (TRYABLE 1) (TRYABLE 0) (TRYABLE 3) (CONS (TRYABLE 5) (TRYABLE 2))
 (CLO (NIL) (VAR (ZERO))) (TRYABLE 3) (TRYABLE 1) (CONS (BOT) (TRYABLE 0))
 (SAFE-NTH (ZERO) (NIL)) (SAFE-NTH (TRYABLE 0) (TRYABLE 2)) (TRYABLE 2)
 (CLO (NIL) (VAR (ZERO))) (TRYABLE 0) (TRYABLE 3) (TRYABLE 4)
 (CLO (NIL) (VAR (ZERO))) (CLO (TRYABLE 3) (TRYABLE 1)) (TRYABLE 1) (TRYABLE 2)
 (TRYABLE 0) (TRYABLE 2) (TRYABLE 0) (TRYABLE 3) (TRYABLE 5)
 (CLO (TRYABLE 4) (VAR (ZERO))) (SAFE-NTH (ZERO) (CONS (BOT) (NIL)))
 (TRYABLE 0) (TRYABLE 3))
  <INFO> [11:50:59] genrec - Profiling ended. 61539 programs, 48034 accepted, 1107702 evaluations, 2046 evaluation errors, 2.271 s real time, 27098.9 p/s, 487779.3 e/s.
#+end_example

Curiously, using a =nested-dispatch-skeleton= roughly equivalent to an "inlined" version of the above =fully-connected-skeleton= also solves the problem, but in very consistent time (10K~20K accepted proposals).
#+begin_src lisp :load no :results output verbatim
(def lc-skeleton
  (nested-dispatch-skeleton
   (function (lc (list-of lcv)) lcv)
   lc lcv))
(with-profiling
    (pprint
     (solve-skeleton-one-try lc-skeleton lc-examples
                     '((safe-nth lcv) (clo lcv) (cons (list-of lcv)))))
  (terpri))
#+end_src

#+RESULTS:
#+begin_example :load no
  <INFO> [18:49:50] genrec - Profiling started
  <INFO> [18:49:51] genrec - Search stopped, 12854 accepted proposals.

((SAFE-NTH (TRYABLE 4) (CONS (TRYABLE 1) (TRYABLE 2))) (TRYABLE 4) (TRYABLE 5)
 (TRYABLE 1) (CONS (BOT) (TRYABLE 4)) (SAFE-NTH (TRYABLE 0) (TRYABLE 2))
 (SAFE-NTH (TRYABLE 0) (NIL)) (CLO (TRYABLE 8) (TRYABLE 3)) (TRYABLE 5)
 (TRYABLE 7) (TRYABLE 1) (CONS (TRYABLE 3) (TRYABLE 6)) (TRYABLE 0)
 (CLO (TRYABLE 4) (TRYABLE 2)) (TRYABLE 1) (TRYABLE 3) (TRYABLE 0) (TRYABLE 2)
 (TRYABLE 0) (TRYABLE 2) (CONS (TRYABLE 4) (TRYABLE 8)) (TRYABLE 5) (TRYABLE 0)
 (SAFE-NTH (ZERO) (CONS (SAFE-NTH (ZERO) (NIL)) (NIL))) (TRYABLE 0) (TRYABLE 1)
 (TRYABLE 4) (TRYABLE 1) (TRYABLE 3) (TRYABLE 0))
  <INFO> [18:49:51] genrec - Profiling ended. 17397 programs, 12853 accepted, 313146 evaluations, 875 evaluation errors, 0.582 s real time, 29878.5 p/s, 537813.1 e/s.
#+end_example

#+RESULTS:
#+begin_example :load no
  <INFO> [18:49:40] genrec - Profiling started
  <INFO> [18:49:40] genrec - Search stopped, 12277 accepted proposals.

((TRYABLE 0) (TRYABLE 2) (CONS (TRYABLE 0) (CONS (BOT) (TRYABLE 1)))
 (TRYABLE 3) (TRYABLE 0) (SAFE-NTH (TRYABLE 0) (TRYABLE 2))
 (SAFE-NTH (TRYABLE 0) (NIL)) (TRYABLE 5) (TRYABLE 2) (TRYABLE 1) (TRYABLE 1)
 (TRYABLE 6) (CLO (TRYABLE 4) (TRYABLE 2)) (SAFE-NTH (ZERO) (NIL)) (TRYABLE 2)
 (CONS (CLO (CONS (BOT) (NIL)) (TRYABLE 1)) (TRYABLE 3)) (TRYABLE 1)
 (TRYABLE 2) (TRYABLE 0) (TRYABLE 2) (CONS (TRYABLE 3) (TRYABLE 8)) (TRYABLE 4)
 (TRYABLE 7) (SAFE-NTH (ZERO) (NIL)) (TRYABLE 1) (TRYABLE 2) (TRYABLE 4)
 (TRYABLE 0) (CONS (SAFE-NTH (ZERO) (TRYABLE 3)) (TRYABLE 3)) (TRYABLE 0))
  <INFO> [18:49:40] genrec - Profiling ended. 16944 programs, 12276 accepted, 304992 evaluations, 992 evaluation errors, 0.556 s real time, 30468.4 p/s, 548430.4 e/s.
#+end_example

#+RESULTS:
#+begin_example :load no
  <INFO> [18:49:31] genrec - Profiling started
  <INFO> [18:49:31] genrec - Search stopped, 13770 accepted proposals.

((SAFE-NTH (TRYABLE 4) (TRYABLE 6)) (TRYABLE 4) (CONS (TRYABLE 0) (TRYABLE 1))
 (TRYABLE 1) (TRYABLE 4) (SAFE-NTH (TRYABLE 0) (TRYABLE 2))
 (CLO (TRYABLE 2) (TRYABLE 1)) (CLO (TRYABLE 8) (TRYABLE 3)) (TRYABLE 5)
 (TRYABLE 1) (TRYABLE 5) (TRYABLE 6) (CLO (NIL) (VAR (ZERO)))
 (CLO (CONS (TRYABLE 0) (TRYABLE 4)) (TRYABLE 2)) (TRYABLE 1) (TRYABLE 3)
 (TRYABLE 0) (TRYABLE 2) (TRYABLE 1) (TRYABLE 6) (TRYABLE 8) (TRYABLE 1)
 (CONS (TRYABLE 2) (TRYABLE 7)) (TRYABLE 1) (TRYABLE 1) (TRYABLE 2) (TRYABLE 4)
 (TRYABLE 0) (TRYABLE 3) (TRYABLE 0))
  <INFO> [18:49:31] genrec - Profiling ended. 18851 programs, 13769 accepted, 339318 evaluations, 1071 evaluation errors, 0.638 s real time, 29559.9 p/s, 532078.3 e/s.
#+end_example

#+RESULTS:
#+begin_example :load no
  <INFO> [18:49:20] genrec - Profiling started
  <INFO> [18:49:21] genrec - Search stopped, 19179 accepted proposals.

((SAFE-NTH (ZERO) (NIL)) (TRYABLE 2)
 (CONS (CLO (NIL) (VAR (ZERO))) (CONS (TRYABLE 0) (TRYABLE 1))) (TRYABLE 3)
 (TRYABLE 0) (SAFE-NTH (TRYABLE 0) (TRYABLE 2)) (SAFE-NTH (TRYABLE 0) (NIL))
 (CLO (TRYABLE 8) (TRYABLE 6)) (TRYABLE 2) (TRYABLE 1) (TRYABLE 5) (TRYABLE 6)
 (CLO (TRYABLE 4) (TRYABLE 2)) (TRYABLE 0) (TRYABLE 1) (TRYABLE 3) (TRYABLE 0)
 (TRYABLE 2) (TRYABLE 1) (TRYABLE 5) (TRYABLE 8) (TRYABLE 1)
 (CONS (TRYABLE 3) (TRYABLE 7)) (TRYABLE 0) (TRYABLE 0) (TRYABLE 1) (TRYABLE 4)
 (TRYABLE 1) (TRYABLE 3) (TRYABLE 0))
  <INFO> [18:49:21] genrec - Profiling ended. 26501 programs, 19178 accepted, 477018 evaluations, 1411 evaluation errors, 0.881 s real time, 30089.5 p/s, 541611.1 e/s.
#+end_example

#+RESULTS:
#+begin_example :load no
  <INFO> [18:49:10] genrec - Profiling started
  <INFO> [18:49:11] genrec - Search stopped, 10903 accepted proposals.

((TRYABLE 1) (TRYABLE 4) (TRYABLE 5) (TRYABLE 3) (TRYABLE 0)
 (SAFE-NTH (TRYABLE 0) (TRYABLE 2)) (SAFE-NTH (TRYABLE 0) (NIL))
 (CLO (TRYABLE 8) (TRYABLE 6)) (TRYABLE 6) (TRYABLE 1) (TRYABLE 1) (TRYABLE 0)
 (CLO (TRYABLE 4) (TRYABLE 2)) (TRYABLE 0) (TRYABLE 1) (TRYABLE 3) (TRYABLE 0)
 (CONS (CLO (NIL) (VAR (ZERO))) (TRYABLE 2)) (TRYABLE 0) (TRYABLE 2)
 (CONS (TRYABLE 3) (TRYABLE 1)) (TRYABLE 6) (CONS (BOT) (TRYABLE 7))
 (TRYABLE 1) (TRYABLE 1) (TRYABLE 2) (TRYABLE 4) (TRYABLE 0) (TRYABLE 3)
 (TRYABLE 0))
  <INFO> [18:49:11] genrec - Profiling ended. 14588 programs, 10902 accepted, 262584 evaluations, 748 evaluation errors, 0.789 s real time, 18480.3 p/s, 332646.3 e/s.
#+end_example

#+begin_src lisp :load no :results output verbatim
(def lc-skeleton
  (fully-connected-skeleton
   (function ((list-of lcv) lcv lc) lcv)
   (function (lc (list-of lcv) lcv) lcv)
   (function (lcv lc (list-of lcv)) lcv)
   (function (lc (list-of lcv)) lcv)))
(with-profiling
  (pprint
   (solve-skeleton-one-try lc-skeleton lc-examples
                           '((safe-nth lcv) (clo lcv) (cons (list-of lcv)))))
  (terpri))
#+end_src

** Stratified Synthesis of Interpreters
Attempted ideas:
- As the starting point, we use a skeleton for the interpreter of the full language (a monolithic ~eval~ entry function and a few helper functions), and give it examples from the full language. This stop working after a few language features (I recall 2 features already stop working).
- Split the full language into sublanguages, and synthesize sublanguages one by one. Use a skeleton for the full interpreter, but give it only examples from a sublanguage at a time. Once a sublanguage is synthesized, use =compute-live-holes= to find all live holes and freeze (using variable =*frozen-holes*=) them when synthesizing subsequent sublanguages, so that the already satisified examples are guaranteed to stay satisfied during subsequent synthesis.
  - This has high probability of not working, because the solution usually use more functions than strictly needed. Some functions are used in a trivial manner, but that makes their holes become live. The next sublanguage then don't have enough changeable functions to synthesize a solution.
  - Manually freezing the unneeded helper functions (e.g. freeze helper functions needed for sublanguage #2 when solving sublanguage #1) make it work for arith+cond, but stop working for arith+cond+lc.
    - For the arith+cond experiments, arith is much harder than cond. It spent a few seconds to solve arith, then finds hundreds of solutions for cond within seconds.
    - For arith+cond+lc, it failed to synthesize first arith sublanguage (and everything after arith doesn't even run) within two minutes.
  - The roadblock is likely the size of the skeleton for the full interpreter (6 helper functions + 1 entry eval function for arith+cond+lc). Even if unneeded functions are frozen, the changeable holes can still call them, and that just introduce too much noise to the search procedures (too easy to get trivial values).
#+begin_src lisp
(uiop:define-package #:genrec/experiments/interpreter
    (:mix #:cl #:genrec #:serapeum)
  (:export
   #:safe-nth))
(in-package #:genrec/experiments/interpreter)
#+end_src
*** Arithmetic
#+begin_src lisp
(define-adt arith-term
  (lit (num nat))
  (add (l term) (r term))
  (bot))
(define-adt arith-value
  (num (value nat))
  (bot))
(define-union term arith-term)
(defproblem arith-eval (term) arith-value
    (term)
  (etypecase term
    (lit (num (lit-num term)))
    (add (let ((l (arith-eval (add-l term)))
               (r (arith-eval (add-r term))))
           (if (and (num-p l) (num-p r))
               (num (+ (num-value l) (num-value r)))
               'bot)))
    ((eql bot) 'bot)))
(def arith-examples
  (inputs-to-examples arith-eval
    ((lit 0))
    ((lit 1))
    ('bot)
    ((add (lit 0) 'bot))
    ((add 'bot (lit 0)))
    ((add 'bot (lit 2)))
    ((add (lit 0) 'bot))
    ((add (lit 2) (lit 0)))
    ((add (lit 0) (lit 2)))
    ((add (lit 1) (lit 2)))))
(def arith-examples-more
  (inputs-to-examples arith-eval
   ((lit 0))
   ((lit 1))
   ('bot)
   ((add (lit 0) 'bot))
   ((add 'bot (lit 0)))
   ((add 'bot (lit 2)))
   ((add (lit 0) (lit 2)))
   ((add (lit 2) (lit 0)))
   ((add (lit 0) (lit 0)))
   ((lit 2))
   ((lit 3))
   ((add (lit 2) (lit 2)))
   ((add (lit 5) (lit 3)))))
(def arith-library '((+ nat) (num arith-value) (bot arith-value)))
#+end_src

Sanity check: The following should be solved with ease (less than 256 searches starting from =*seed*=0=).
Note that this only works after replacing the recursive references =term='s in =(define-adt arith-term ...)= with =arith-term=.
#+begin_src lisp :load no
(def arith-skeleton-1
  (fully-connected-skeleton
   (function (arith-value nat) arith-value)
   (function (arith-value arith-term) arith-value)
   (function (arith-term) arith-value)))
#+end_src

#+begin_src lisp
(def arith-skeleton-1
  (fully-connected-skeleton
   (function (arith-value nat) arith-value)
   (function (arith-value term) arith-value)
   (function (term) arith-value)))
  #+nil  (def arith-skeleton
    (interpreter-skeleton term
      (function (arith-value nat) arith-value)
      (function (arith-value term) arith-value)
      (function (arith-term) arith-value)))
(def arith-skeleton
  (call-graph-skeleton
   (arith-1 (function (arith-value nat) arith-value)
            arith-1 arith-2 eval-toplevel)
   (arith-2 (function (arith-value term) arith-value)
            arith-1 arith-2 eval-toplevel)
   (eval-toplevel (function (term) arith-value)
                  arith-1 arith-2 eval-toplevel)))
#+end_src

*** Conditional
#+begin_src lisp
(define-adt cond-term
  (ifz (test term) (then term) (else term)))
(define-union term arith-term cond-term)
(defproblem cond-eval (term) arith-value
    (term)
  (etypecase term
    (lit (num (lit-num term)))
    (add (let ((l (cond-eval (add-l term)))
               (r (cond-eval (add-r term))))
           (if (and (num-p l) (num-p r))
               (num (+ (num-value l) (num-value r)))
               'bot)))
    (ifz (let ((test (cond-eval (ifz-test term))))
           (typecase test
             (num (if (zerop (num-value test))
                      (cond-eval (ifz-then term))
                      (cond-eval (ifz-else term))))
             (t 'bot))))
    ((eql bot) 'bot)))
(def cond-examples
  (inputs-to-examples cond-eval
   ((ifz (lit 0) (lit 0) (lit 2)))
   ((ifz (lit 1) (lit 0) (lit 2)))
   ((ifz (lit 0) (add (lit 0) (lit 2)) (lit 0)))
   ((ifz (lit 0) (add (lit 1) (lit 2)) (lit 0)))
   ((ifz (lit 0) 'bot 'bot))
   ((ifz (lit 1) (lit 0) (add (lit 0) (lit 2))))
   ((ifz (lit 1) (lit 0) (add (lit 1) (lit 2))))
   ((ifz (lit 1) 'bot 'bot))))
#+nil (def cond-skeleton
  (interpreter-skeleton term
    (function (nat term term) arith-value)
    (function (arith-value term term) arith-value)
    (function (cond-term) arith-value)))
(def cond-skeleton
  (call-graph-skeleton
   (arith-1 (function (arith-value nat) arith-value)
            arith-1 arith-2 eval-toplevel)
   (arith-2 (function (arith-value term) arith-value)
            arith-1 arith-2 eval-toplevel)
   (arith-eval (function (arith-term) arith-value)
               arith-1 arith-2 eval-toplevel)
   (cond-1 (function (nat term term) arith-value)
           cond-1 cond-2 eval-toplevel)
   (cond-2 (function (arith-value term term) arith-value)
           cond-1 cond-2 eval-toplevel)
   (cond-eval (function (cond-term) arith-value)
              cond-1 cond-2 eval-toplevel)
   (eval-toplevel (function (term) arith-value)
                  :code (term)
                  (etypecase term
                    (arith-term (arith-eval term))
                    (cond-term (cond-eval term))))))
(def cond-library arith-library)
#+end_src

This is solved (specificially the =arith= strata) without pre-freezing:
#+begin_src lisp :load no
(def cond/arith-par (solve-skeleton 'cond-skeleton 'arith-examples arith-library))
cond/arith-par
#+end_src

#+RESULTS:
#+begin_src lisp :load no
((TRYABLE 2) (TRYABLE 3) (TRYABLE 0) (BOT) (BOT)
 (NUM (+ (TRYABLE 3) (TRYABLE 5))) (BOT) (TRYABLE 4) (NUM (ZERO)) (BOT) (BOT)
 (TRYABLE 3) (TRYABLE 2) (TRYABLE 3) (TRYABLE 4) (TRYABLE 5) (TRYABLE 5)
 (TRYABLE 0) (TRYABLE 0) (ZERO) (TRYABLE 3) (TRYABLE 4) (TRYABLE 4) (TRYABLE 3)
 (NUM (ZERO)) (TRYABLE 3) (TRYABLE 2) (BOT) (BOT) (TRYABLE 0) (TRYABLE 2)
 (+ (ZERO) (ZERO)) (TRYABLE 2) (TRYABLE 4) (TRYABLE 3) (TRYABLE 1) (TRYABLE 0)
 (ZERO) (BOT) (BOT) (BOT) (BOT) (+ (TRYABLE 3) (TRYABLE 3)) (TRYABLE 5)
 (TRYABLE 5) (TRYABLE 0) (TRYABLE 5) (TRYABLE 5) (TRYABLE 4) (TRYABLE 0)
 (+ (TRYABLE 3) (TRYABLE 3)) (TRYABLE 6) (TRYABLE 5) (TRYABLE 2) (TRYABLE 6)
 (TRYABLE 5) (TRYABLE 5) (TRYABLE 0) (+ (TRYABLE 3) (TRYABLE 3)) (TRYABLE 6)
 (TRYABLE 5) (TRYABLE 1) (TRYABLE 5) (TRYABLE 5) (TRYABLE 6) (TRYABLE 2) (ZERO)
 (TRYABLE 4) (TRYABLE 5) (TRYABLE 3) (TRYABLE 5) (TRYABLE 4) (TRYABLE 4)
 (TRYABLE 1) (ZERO) (TRYABLE 4) (TRYABLE 3) (TRYABLE 1) (TRYABLE 4) (TRYABLE 4)
 (TRYABLE 3) (TRYABLE 2))
#+end_src

#+begin_src lisp :load no
(let ((genrec::*initial-par* cond/arith-par)
      (genrec::*frozen-holes*
        (genrec::compute-live-holes cond-skeleton arith-examples cond/arith-par)))
  (solve-skeleton 'cond-skeleton 'cond-examples arith-library))
#+end_src

#+RESULTS:
#+begin_src lisp :load no
((BOT) (TRYABLE 5) (TRYABLE 2) (BOT) (BOT) (NUM (+ (TRYABLE 3) (TRYABLE 5)))
 (TRYABLE 3) (TRYABLE 4) (TRYABLE 3) (BOT) (BOT) (TRYABLE 3) (TRYABLE 2)
 (TRYABLE 3) (TRYABLE 2) (TRYABLE 5) (TRYABLE 5) (TRYABLE 0) (TRYABLE 2) (ZERO)
 (TRYABLE 3) (TRYABLE 4) (TRYABLE 4) (TRYABLE 3) (NUM (ZERO)) (TRYABLE 3)
 (TRYABLE 0) (BOT) (BOT) (TRYABLE 0) (TRYABLE 0) (+ (ZERO) (ZERO)) (TRYABLE 2)
 (TRYABLE 4) (TRYABLE 3) (TRYABLE 1) (TRYABLE 1) (+ (ZERO) (ZERO)) (TRYABLE 0)
 (BOT) (BOT) (BOT) (TRYABLE 3) (TRYABLE 4) (TRYABLE 5) (TRYABLE 1) (TRYABLE 4)
 (TRYABLE 5) (TRYABLE 4) (TRYABLE 2) (TRYABLE 4) (TRYABLE 5) (TRYABLE 6)
 (NUM (ZERO)) (TRYABLE 5) (TRYABLE 6) (TRYABLE 6) (TRYABLE 1) (TRYABLE 3)
 (TRYABLE 6) (TRYABLE 5) (BOT) (TRYABLE 5) (TRYABLE 5) (TRYABLE 5) (TRYABLE 0)
 (ZERO) (TRYABLE 4) (TRYABLE 5) (TRYABLE 3) (TRYABLE 4) (TRYABLE 4) (TRYABLE 5)
 (BOT) (ZERO) (TRYABLE 3) (TRYABLE 5) (TRYABLE 0) (TRYABLE 5) (TRYABLE 4)
 (TRYABLE 4) (TRYABLE 1))
#+end_src

*** Lambda Calculus
#+begin_src lisp
(define-adt lc-term
  (var (index nat))
  (lam (body term))
  (app (op term) (arg term)))
(define-adt lc-value
  (clo (env (list-of lc-value)) (body term))
  (num (value nat))
  (bot))
(define-union term arith-term cond-term lc-term)
(defun safe-nth (n l)
  (let ((cons (nthcdr n l)))
    (if cons (car cons) 'bot)))
(setf (get 'safe-nth 'arg-types) (lambda (r) `(nat (list-of ,r))))
(defproblem lc-eval
    (term (list-of lc-value)) lc-value
    (term env)
  (etypecase term
    (var (safe-nth (var-index term) env))
    (app (let ((op (lc-eval (app-op term) env))
               (arg (lc-eval (app-arg term) env)))
           (typecase op
             (clo (lc-eval (clo-body op) (cons arg (clo-env op))))
             (t 'bot))))
    (lam (clo env (lam-body term)))
    (lit (num (lit-num term)))
    (add (let ((l (lc-eval (add-l term) env))
               (r (lc-eval (add-r term) env)))
           (if (and (num-p l) (num-p r))
               (num (+ (num-value l) (num-value r)))
               'bot)))
    ((eql bot) 'bot)))
(def arith-examples-with-env
  (mapcar (lambda (e) (list (append (car e) (list nil)) (cadr e)))
          arith-examples))
(def cond-examples-with-env
  (mapcar (lambda (e) (list (append (car e) (list nil)) (cadr e)))
          cond-examples))
(def lc-examples
  (inputs-to-examples lc-eval
   ((lam (var 0)) nil)
   ((lam (var 1)) nil)
   ((lam (var 0)) (list 'bot))
   ((lam (var 1)) (list 'bot))
   ((lam (var 1)) (list (clo nil (var 0))))
   ((var 0) (list (clo nil (var 0))))
   ((var 1) (list (clo nil (var 0))))
   ((lam (lam (var 0))) nil)
   ((app (lam (var 0)) (lam (var 0))) nil)
   ((app (var 0) (var 0)) nil)
   ((app (lam (var 0)) (var 0)) nil)
   ((app (var 0) (lam (var 0))) nil)
   ((app (app (lam (lam (var 0))) (lam (var 0))) (lam (var 0))) nil)
   ((app (app (lam (lam (var 0))) (lam (var 1))) (lam (var 0))) nil)
   ((app (app (lam (lam (var 0))) (lam (var 0))) (lam (var 1))) nil)
   ((app (lam (lam (var 0))) (lam (var 0))) nil)
   ((app (lam (lam (var 0))) (lam (var 1))) nil)
   ((app (lam (lam (var 1))) (lam (var 0))) nil)))
(def lc-skeleton
  (call-graph-skeleton
   (arith-1 (function (lc-value nat) lc-value)
            arith-1 arith-2 eval-toplevel)
   (arith-2 (function (lc-value term (list-of lc-value)) lc-value)
            arith-1 arith-2 eval-toplevel)
   (arith-eval (function (arith-term (list-of lc-value)) lc-value)
               arith-1 arith-2 eval-toplevel)
   (cond-1 (function (nat term term (list-of lc-value)) lc-value)
           cond-1 cond-2 eval-toplevel)
   (cond-2 (function (lc-value term term (list-of lc-value)) lc-value)
           cond-1 cond-2 eval-toplevel)
   (cond-eval (function (cond-term (list-of lc-value)) lc-value)
               cond-1 cond-2 eval-toplevel)
   (lc-1 (function (lc-value lc-value) lc-value)
         lc-1 lc-2 eval-toplevel)
   (lc-2 (function (lc-value term (list-of lc-value)) lc-value)
         lc-1 lc-2 eval-toplevel)
   (lc-eval (function (lc-term (list-of lc-value)) lc-value)
            lc-1 lc-2 eval-toplevel)
   (eval-toplevel (function (term (list-of lc-value)) lc-value)
                  :code (term env)
                  (etypecase term
                    (arith-term (arith-eval term env))
                    (cond-term (cond-eval term env))
                    (lc-term (lc-eval term env))))))
#+nil (def lc/arith-skeleton
  (interpreter-skeleton term
    (function (lc-value nat) lc-value)
    (function (lc-value term (list-of lc-value)) lc-value)
    (function (arith-term (list-of lc-value)) lc-value)))
#+nil (def lc/cond-skeleton
  (interpreter-skeleton term
   (function (nat term term (list-of lc-value)) lc-value)
   (function (lc-value term term (list-of lc-value)) lc-value)
   (function (cond-term (list-of lc-value)) lc-value)))
#+nil (def lc-skeleton
  (interpreter-skeleton term
    (function (lc-value lc-value) lc-value)
    (function (lc-value term (list-of lc-value)) lc-value)
    (function (lc-term (list-of lc-value)) lc-value)))
#+nil (def lc-skeleton-1
  (fully-connected-skeleton
   (function (lc-value lc-value) lc-value)
   (function (lc-value lc-term (list-of lc-value)) lc-value)
   (function (lc-value (list-of lc-value)) lc-value)))
(def lc-library '((+ nat) (num lc-value) (bot lc-value)
                  (clo lc-value) (safe-nth lc-value)
                  (cons (list-of lc-value))))
#+end_src

Pre-freezing is now necessary to solve the first strata (=arith= strata).

#+begin_src lisp :load no
(def lc/arith-par
  (let ((genrec::*frozen-holes* (genrec::holes-for-functions lc-skeleton '(3 4 5 6 7 8))))
    (solve-skeleton 'lc-skeleton 'arith-examples-with-env
                    '((+ nat) (num lc-value) (bot lc-value)))))
lc/arith-par
#+end_src

#+RESULTS:
#+begin_src lisp :load no
((TRYABLE 2) (TRYABLE 6) (TRYABLE 0) (TRYABLE 4) (TRYABLE 3) (TRYABLE 4)
 (TRYABLE 3) (TRYABLE 5) (TRYABLE 4) (TRYABLE 5) (TRYABLE 0) (BOT) (NIL) (BOT)
 (NIL) (NUM (+ (TRYABLE 5) (TRYABLE 3))) (TRYABLE 0) (TRYABLE 4) (TRYABLE 2)
 (BOT) (NIL) (BOT) (NIL) (BOT) (BOT) (ZERO) (NUM (ZERO)) (TRYABLE 4)
 (TRYABLE 7) (TRYABLE 6) (TRYABLE 3) (TRYABLE 5) (TRYABLE 2) (TRYABLE 3)
 (TRYABLE 2) (TRYABLE 5) (TRYABLE 6) (TRYABLE 5) (TRYABLE 6) (TRYABLE 0)
 (TRYABLE 3) (ZERO) (TRYABLE 3) (TRYABLE 4) (TRYABLE 5) (TRYABLE 4) (TRYABLE 5)
 (TRYABLE 3) (TRYABLE 2) (TRYABLE 3) (TRYABLE 1) (BOT) (TRYABLE 5) (BOT)
 (TRYABLE 5) (NUM (TRYABLE 3)) (BOT) (ZERO) (TRYABLE 2) (TRYABLE 3) (TRYABLE 6)
 (TRYABLE 4) (TRYABLE 6) (TRYABLE 1) (BOT) (+ (ZERO) (ZERO)) (TRYABLE 2) (BOT)
 (TRYABLE 4) (BOT) (TRYABLE 4) (TRYABLE 0) (ZERO) (BOT) (BOT) (NIL) (BOT) (BOT)
 (BOT) (NIL) (BOT) (NIL) (BOT) (ZERO) (BOT) (BOT) (NIL) (BOT) (BOT) (BOT) (NIL)
 (BOT) (NIL) (BOT) (ZERO) (BOT) (BOT) (NIL) (BOT) (BOT) (BOT) (NIL) (BOT) (NIL)
 (BOT) (ZERO) (BOT) (BOT) (NIL) (BOT) (BOT) (BOT) (NIL) (BOT) (NIL) (BOT)
 (ZERO) (BOT) (BOT) (NIL) (BOT) (BOT) (BOT) (NIL) (BOT) (NIL) (BOT) (ZERO)
 (BOT) (BOT) (NIL) (BOT) (BOT) (BOT) (NIL) (BOT) (NIL) (BOT) (BOT) (BOT) (BOT)
 (BOT) (NIL) (BOT) (NIL) (BOT) (BOT) (BOT) (BOT) (BOT) (NIL) (BOT) (NIL) (BOT)
 (BOT) (BOT) (BOT) (BOT) (NIL) (BOT) (NIL) (BOT) (BOT) (BOT) (BOT) (BOT) (NIL)
 (BOT) (NIL) (BOT) (BOT) (BOT) (BOT) (BOT) (NIL) (BOT) (NIL) (BOT) (BOT) (BOT)
 (BOT) (BOT) (NIL) (BOT) (NIL) (BOT) (BOT) (BOT) (BOT) (BOT) (NIL) (BOT) (NIL)
 (BOT) (BOT) (BOT) (BOT) (BOT) (NIL) (BOT) (NIL) (BOT) (BOT) (BOT) (BOT) (BOT)
 (NIL) (BOT) (NIL) (BOT))
#+end_src

#+begin_src lisp :load no
(def lc/cond-par
  (let ((genrec::*frozen-holes*
          (union (genrec::compute-live-holes lc-skeleton arith-examples-with-env lc/arith-par)
                 (genrec::holes-for-functions lc-skeleton '(6 7 8))))
        (genrec::*initial-par* lc/arith-par))
    (solve-skeleton 'lc-skeleton cond-examples-with-env '((bot lc-value)))))
lc/cond-par
#+end_src

#+RESULTS:
#+begin_src lisp :load no
((TRYABLE 2) (TRYABLE 6) (TRYABLE 0) (TRYABLE 4) (TRYABLE 3) (TRYABLE 4)
 (TRYABLE 3) (BOT) (TRYABLE 1) (TRYABLE 5) (TRYABLE 4) (BOT) (NIL) (BOT) (NIL)
 (NUM (+ (TRYABLE 5) (TRYABLE 3))) (TRYABLE 1) (TRYABLE 4) (TRYABLE 0) (BOT)
 (NIL) (BOT) (NIL) (BOT) (TRYABLE 1) (ZERO) (TRYABLE 5) (TRYABLE 4) (TRYABLE 3)
 (TRYABLE 4) (TRYABLE 7) (TRYABLE 1) (TRYABLE 2) (TRYABLE 3) (TRYABLE 4)
 (TRYABLE 5) (TRYABLE 6) (TRYABLE 5) (TRYABLE 6) (TRYABLE 0) (TRYABLE 0) (ZERO)
 (TRYABLE 3) (TRYABLE 4) (TRYABLE 5) (TRYABLE 4) (TRYABLE 5) (TRYABLE 3)
 (TRYABLE 1) (TRYABLE 3) (TRYABLE 1) (BOT) (TRYABLE 5) (BOT) (TRYABLE 5)
 (NUM (TRYABLE 3)) (BOT) (ZERO) (TRYABLE 2) (TRYABLE 3) (TRYABLE 6) (TRYABLE 4)
 (TRYABLE 6) (TRYABLE 1) (BOT) (+ (ZERO) (ZERO)) (TRYABLE 1) (BOT) (TRYABLE 4)
 (BOT) (TRYABLE 4) (TRYABLE 0) (TRYABLE 3) (TRYABLE 5) (TRYABLE 4) (TRYABLE 6)
 (TRYABLE 2) (TRYABLE 5) (TRYABLE 4) (TRYABLE 6) (TRYABLE 5) (TRYABLE 6)
 (TRYABLE 1) (TRYABLE 3) (TRYABLE 6) (TRYABLE 5) (TRYABLE 7) (BOT) (TRYABLE 5)
 (TRYABLE 5) (TRYABLE 7) (TRYABLE 5) (TRYABLE 7) (BOT) (ZERO) (TRYABLE 7)
 (TRYABLE 4) (TRYABLE 3) (TRYABLE 2) (TRYABLE 7) (TRYABLE 7) (TRYABLE 8)
 (TRYABLE 7) (TRYABLE 8) (TRYABLE 2) (TRYABLE 3) (TRYABLE 5) (TRYABLE 6)
 (TRYABLE 7) (TRYABLE 0) (TRYABLE 6) (TRYABLE 5) (TRYABLE 7) (TRYABLE 5)
 (TRYABLE 7) (TRYABLE 1) (ZERO) (TRYABLE 5) (TRYABLE 5) (TRYABLE 6) (BOT)
 (TRYABLE 4) (TRYABLE 5) (TRYABLE 6) (TRYABLE 5) (TRYABLE 6) (TRYABLE 2) (ZERO)
 (TRYABLE 3) (TRYABLE 4) (TRYABLE 7) (TRYABLE 2) (TRYABLE 5) (TRYABLE 4)
 (TRYABLE 7) (TRYABLE 3) (TRYABLE 7) (TRYABLE 1) (BOT) (BOT) (BOT) (BOT) (NIL)
 (BOT) (NIL) (BOT) (BOT) (BOT) (BOT) (BOT) (NIL) (BOT) (NIL) (BOT) (BOT) (BOT)
 (BOT) (BOT) (NIL) (BOT) (NIL) (BOT) (BOT) (BOT) (BOT) (BOT) (NIL) (BOT) (NIL)
 (BOT) (BOT) (BOT) (BOT) (BOT) (NIL) (BOT) (NIL) (BOT) (BOT) (BOT) (BOT) (BOT)
 (NIL) (BOT) (NIL) (BOT) (BOT) (BOT) (BOT) (BOT) (NIL) (BOT) (NIL) (BOT) (BOT)
 (BOT) (BOT) (BOT) (NIL) (BOT) (NIL) (BOT) (BOT) (BOT) (BOT) (BOT) (NIL) (BOT)
 (NIL) (BOT))
#+end_src

#+begin_src lisp :load no
(def lc-par
  (let ((genrec::*frozen-holes*
          (union (genrec::compute-live-holes lc-skeleton arith-examples-with-env lc/cond-par)
                 (genrec::compute-live-holes lc-skeleton cond-examples-with-env lc/cond-par)))
        (genrec::*initial-par* lc/cond-par))
    (solve-skeleton 'lc-skeleton lc-examples '((bot lc-value)
                                               (clo lc-value) (safe-nth lc-value)
                                              (cons (list-of lc-value))))))
lc-par
#+end_src

#+RESULTS:
#+begin_src lisp :load no
((BOT) (TRYABLE 6) (TRYABLE 0) (TRYABLE 4) (TRYABLE 3) (TRYABLE 4) (TRYABLE 3)
 (TRYABLE 1) (TRYABLE 2) (TRYABLE 5) (TRYABLE 2) (BOT) (NIL) (BOT) (NIL)
 (NUM (+ (TRYABLE 5) (TRYABLE 3))) (SAFE-NTH (ZERO) (NIL)) (TRYABLE 4)
 (CLO (NIL) (BOT)) (BOT) (CONS (TRYABLE 1) (NIL)) (BOT)
 (CONS (TRYABLE 3) (CONS (TRYABLE 1) (NIL))) (BOT) (TRYABLE 5) (ZERO)
 (TRYABLE 5) (TRYABLE 6) (TRYABLE 3) (TRYABLE 4) (TRYABLE 7) (TRYABLE 1)
 (TRYABLE 2) (TRYABLE 3) (TRYABLE 0) (TRYABLE 5) (TRYABLE 6) (TRYABLE 5)
 (TRYABLE 6) (TRYABLE 0) (TRYABLE 0) (ZERO) (TRYABLE 0) (TRYABLE 4) (TRYABLE 5)
 (TRYABLE 4) (TRYABLE 5) (TRYABLE 3) (TRYABLE 0) (TRYABLE 3) (TRYABLE 2) (BOT)
 (TRYABLE 5) (BOT) (CONS (BOT) (CONS (BOT) (CONS (BOT) (TRYABLE 5))))
 (NUM (TRYABLE 3)) (CLO (NIL) (TRYABLE 3)) (ZERO) (TRYABLE 2) (TRYABLE 3)
 (TRYABLE 6) (TRYABLE 4) (TRYABLE 6) (TRYABLE 1) (BOT) (+ (ZERO) (ZERO))
 (TRYABLE 0) (BOT) (TRYABLE 4) (BOT) (TRYABLE 4) (TRYABLE 0) (TRYABLE 3)
 (TRYABLE 5) (TRYABLE 4) (TRYABLE 6) (TRYABLE 2) (TRYABLE 5) (TRYABLE 4)
 (TRYABLE 6) (TRYABLE 5) (TRYABLE 6) (TRYABLE 1) (TRYABLE 3) (TRYABLE 5)
 (TRYABLE 6) (CONS (BOT) (TRYABLE 7)) (TRYABLE 2) (TRYABLE 5) (TRYABLE 6)
 (TRYABLE 7) (TRYABLE 6) (TRYABLE 7) (BOT) (ZERO) (TRYABLE 7) (TRYABLE 7)
 (TRYABLE 3) (TRYABLE 5) (TRYABLE 7) (TRYABLE 7) (CONS (BOT) (TRYABLE 8))
 (TRYABLE 6) (CONS (BOT) (TRYABLE 8)) (TRYABLE 2) (TRYABLE 3) (TRYABLE 5)
 (TRYABLE 6) (TRYABLE 7) (TRYABLE 0) (TRYABLE 6) (TRYABLE 5) (TRYABLE 7)
 (TRYABLE 6) (TRYABLE 7) (TRYABLE 1) (ZERO) (TRYABLE 5) (TRYABLE 4) (TRYABLE 6)
 (TRYABLE 1) (TRYABLE 5) (TRYABLE 5) (TRYABLE 6) (TRYABLE 5) (TRYABLE 6)
 (TRYABLE 2) (ZERO) (TRYABLE 5) (TRYABLE 5)
 (CONS (TRYABLE 0) (CONS (TRYABLE 1) (TRYABLE 7))) (TRYABLE 2) (TRYABLE 5)
 (TRYABLE 4) (TRYABLE 7) (TRYABLE 3) (TRYABLE 7) (TRYABLE 1) (TRYABLE 1) (BOT)
 (TRYABLE 6) (TRYABLE 4) (CONS (BOT) (CONS (BOT) (TRYABLE 3))) (TRYABLE 4)
 (CONS (TRYABLE 1) (TRYABLE 3)) (TRYABLE 2) (TRYABLE 4) (TRYABLE 0) (TRYABLE 0)
 (BOT)
 (CONS (TRYABLE 2)
       (CONS (TRYABLE 0)
             (CONS (TRYABLE 1)
                   (CONS (BOT)
                         (CONS (BOT)
                               (CONS (TRYABLE 2)
                                     (CONS (SAFE-NTH (ZERO) (NIL))
                                           (CONS (BOT)
                                                 (CONS (TRYABLE 0)
                                                       (NIL))))))))))
 (BOT) (CONS (TRYABLE 5) (CONS (BOT) (CONS (BOT) (NIL)))) (TRYABLE 2)
 (TRYABLE 0) (BOT) (TRYABLE 3) (BOT) (CONS (TRYABLE 3) (NIL)) (BOT)
 (CONS (TRYABLE 1)
       (CONS (TRYABLE 1)
             (CONS (BOT)
                   (CONS (SAFE-NTH (ZERO) (NIL))
                         (CONS (SAFE-NTH (ZERO) (NIL)) (NIL))))))
 (SAFE-NTH (ZERO) (NIL)) (TRYABLE 2) (TRYABLE 5) (TRYABLE 2) (TRYABLE 4)
 (CONS (TRYABLE 2) (TRYABLE 3)) (TRYABLE 4) (TRYABLE 7) (TRYABLE 5) (TRYABLE 0)
 (TRYABLE 4) (TRYABLE 0) (TRYABLE 5) (CONS (BOT) (TRYABLE 6)) (TRYABLE 5)
 (TRYABLE 6) (CLO (TRYABLE 6) (BOT)) (TRYABLE 1) (TRYABLE 3) (TRYABLE 2)
 (TRYABLE 4) (TRYABLE 5) (TRYABLE 4) (TRYABLE 5) (TRYABLE 2) (TRYABLE 0)
 (TRYABLE 2) (TRYABLE 1) (BOT) (TRYABLE 5) (BOT)
 (CONS (BOT) (CONS (SAFE-NTH (ZERO) (NIL)) (CONS (BOT) (TRYABLE 5))))
 (SAFE-NTH (TRYABLE 3) (TRYABLE 5)) (TRYABLE 1) (BOT)
 (CLO (TRYABLE 5) (TRYABLE 3)) (TRYABLE 3) (TRYABLE 5) (TRYABLE 3)
 (CONS (BOT) (CONS (BOT) (TRYABLE 5))) (TRYABLE 1) (TRYABLE 1) (TRYABLE 2)
 (SAFE-NTH (ZERO) (NIL)) (TRYABLE 3) (TRYABLE 6) (TRYABLE 4) (TRYABLE 6)
 (TRYABLE 0))
#+end_src

It turns out that the above examples don't constrain the solution enough -- they doesn't specify how =arith-term= or =cond-term= inside =lc-term= shall be evaluated.

#+begin_src lisp
(def lc-examples-more
  (inputs-to-examples lc-eval
   ((app (lam (var 0)) (lit 0)) nil)
   ((app (lam (add (lit 1) (var 0))) (lit 0)) nil)
   ((app (lam (add (lit 0) (var 0))) (lit 1)) nil)
   ((app (lit 0) (lit 0)) nil)))
#+end_src

#+begin_src lisp :load no
(def lc-par-revised
  (let ((genrec::*frozen-holes*
          (genrec::compute-live-holes
           lc-skeleton
           (append arith-examples-with-env cond-examples-with-env lc-examples)
           lc-par))
        (genrec::*initial-par* lc-par))
    (solve-skeleton 'lc-skeleton lc-examples-more '((bot lc-value)
                                              (clo lc-value) (safe-nth lc-value)
                                                   (cons (list-of lc-value))))))
lc-par-revised
#+end_src

#+RESULTS:
#+begin_src lisp :load no
((TRYABLE 5) (TRYABLE 6) (TRYABLE 1) (TRYABLE 4)
 (CONS (CLO (NIL) (BOT)) (TRYABLE 3)) (TRYABLE 4)
 (CONS (TRYABLE 0) (CONS (TRYABLE 5) (TRYABLE 3))) (TRYABLE 1) (TRYABLE 0)
 (TRYABLE 5) (TRYABLE 2) (BOT) (NIL) (BOT) (NIL)
 (NUM (+ (TRYABLE 5) (TRYABLE 3))) (CLO (NIL) (BOT)) (TRYABLE 4) (TRYABLE 3)
 (BOT) (CONS (BOT) (NIL)) (BOT) (CONS (BOT) (NIL)) (BOT) (TRYABLE 1) (ZERO)
 (TRYABLE 1) (TRYABLE 6) (TRYABLE 3) (TRYABLE 6) (TRYABLE 7) (TRYABLE 5)
 (TRYABLE 2) (TRYABLE 3) (TRYABLE 4) (TRYABLE 5) (TRYABLE 6) (TRYABLE 5)
 (TRYABLE 6) (TRYABLE 0) (TRYABLE 1) (ZERO) (SAFE-NTH (ZERO) (NIL)) (TRYABLE 4)
 (CONS (SAFE-NTH (ZERO) (NIL)) (TRYABLE 5)) (TRYABLE 4) (TRYABLE 5) (TRYABLE 3)
 (TRYABLE 1) (TRYABLE 3) (TRYABLE 2) (BOT) (TRYABLE 5) (BOT) (TRYABLE 5)
 (NUM (TRYABLE 3)) (TRYABLE 2) (ZERO) (TRYABLE 2) (TRYABLE 3) (TRYABLE 6)
 (TRYABLE 4) (TRYABLE 6) (TRYABLE 1) (BOT) (+ (ZERO) (ZERO)) (TRYABLE 1) (BOT)
 (TRYABLE 4) (BOT) (TRYABLE 4) (TRYABLE 0) (TRYABLE 3) (TRYABLE 4) (TRYABLE 5)
 (TRYABLE 6) (TRYABLE 2) (TRYABLE 5) (TRYABLE 4) (TRYABLE 6) (TRYABLE 5)
 (TRYABLE 6) (TRYABLE 1) (TRYABLE 4) (TRYABLE 6) (TRYABLE 6) (TRYABLE 7)
 (TRYABLE 2) (TRYABLE 6) (TRYABLE 6) (CONS (BOT) (TRYABLE 7)) (TRYABLE 5)
 (TRYABLE 7) (BOT) (ZERO) (TRYABLE 6) (TRYABLE 4) (CONS (BOT) (TRYABLE 8))
 (TRYABLE 1) (TRYABLE 7) (TRYABLE 4) (TRYABLE 8) (TRYABLE 6) (TRYABLE 8)
 (TRYABLE 1) (TRYABLE 3) (TRYABLE 5) (TRYABLE 6) (TRYABLE 7) (TRYABLE 0)
 (TRYABLE 6) (TRYABLE 5) (TRYABLE 7) (TRYABLE 6) (TRYABLE 7) (TRYABLE 1) (ZERO)
 (TRYABLE 5) (TRYABLE 5) (TRYABLE 6) (CLO (NIL) (BOT)) (TRYABLE 4) (TRYABLE 4)
 (TRYABLE 6) (TRYABLE 5) (TRYABLE 6) (TRYABLE 2) (ZERO) (TRYABLE 5) (TRYABLE 5)
 (CONS (TRYABLE 0) (CONS (BOT) (CONS (BOT) (CONS (TRYABLE 0) (TRYABLE 7)))))
 (TRYABLE 2) (TRYABLE 5) (TRYABLE 4) (TRYABLE 7) (TRYABLE 3) (TRYABLE 7)
 (TRYABLE 1) (TRYABLE 6) (TRYABLE 6) (TRYABLE 6) (TRYABLE 4)
 (CONS (BOT) (CONS (BOT) (TRYABLE 3))) (TRYABLE 4)
 (CONS (TRYABLE 1) (TRYABLE 3)) (TRYABLE 2) (BOT) (TRYABLE 2) (TRYABLE 5) (BOT)
 (CONS (BOT)
       (CONS (TRYABLE 4)
             (CONS (TRYABLE 4)
                   (CONS (TRYABLE 5)
                         (CONS (BOT)
                               (CONS (TRYABLE 1)
                                     (CONS (TRYABLE 4)
                                           (CONS (TRYABLE 1)
                                                 (CONS (BOT)
                                                       (CONS (BOT)
                                                             (CONS (TRYABLE 2)
                                                                   (CONS
                                                                    (SAFE-NTH
                                                                     (ZERO)
                                                                     (NIL))
                                                                    (CONS (BOT)
                                                                          (CONS
                                                                           (TRYABLE
                                                                            0)
                                                                           (NIL)))))))))))))))
 (BOT)
 (CONS (TRYABLE 2)
       (CONS (TRYABLE 2)
             (CONS (BOT) (CONS (TRYABLE 1) (CONS (TRYABLE 0) (NIL))))))
 (BOT) (TRYABLE 0) (TRYABLE 2) (TRYABLE 2) (BOT) (NIL) (BOT)
 (CONS (TRYABLE 3)
       (CONS (TRYABLE 1)
             (CONS (TRYABLE 0)
                   (CONS (BOT)
                         (CONS (SAFE-NTH (ZERO) (NIL))
                               (CONS (SAFE-NTH (ZERO) (NIL)) (NIL)))))))
 (SAFE-NTH (ZERO) (NIL)) (TRYABLE 2) (TRYABLE 1) (TRYABLE 1) (TRYABLE 6)
 (TRYABLE 3) (TRYABLE 4) (TRYABLE 7) (TRYABLE 5) (TRYABLE 0) (TRYABLE 0)
 (TRYABLE 1) (TRYABLE 5) (TRYABLE 6) (TRYABLE 5) (TRYABLE 6) (TRYABLE 4)
 (TRYABLE 1) (TRYABLE 2) (CLO (NIL) (BOT)) (TRYABLE 4) (TRYABLE 5) (TRYABLE 4)
 (TRYABLE 5) (TRYABLE 2) (TRYABLE 2) (SAFE-NTH (ZERO) (NIL)) (TRYABLE 2) (BOT)
 (CONS (TRYABLE 0) (CONS (BOT) (TRYABLE 5))) (BOT)
 (CONS (BOT) (CONS (BOT) (TRYABLE 5))) (SAFE-NTH (TRYABLE 3) (TRYABLE 5))
 (TRYABLE 2) (TRYABLE 2) (CLO (TRYABLE 5) (TRYABLE 3)) (TRYABLE 3) (TRYABLE 5)
 (TRYABLE 3) (TRYABLE 5) (TRYABLE 1) (TRYABLE 1) (TRYABLE 2)
 (SAFE-NTH (ZERO) (NIL)) (TRYABLE 3) (TRYABLE 6) (TRYABLE 4) (TRYABLE 6)
 (TRYABLE 0))
#+end_src

Can we do it in one go with =(append lc-examples lc-examples-more)=? Yes!

#+begin_src lisp :load no
(def lc-par-1
  (let ((genrec::*frozen-holes*
          (union (genrec::compute-live-holes lc-skeleton arith-examples-with-env lc/cond-par)
                 (genrec::compute-live-holes lc-skeleton cond-examples-with-env lc/cond-par)))
        (genrec::*initial-par* lc/cond-par))
    (solve-skeleton 'lc-skeleton (append lc-examples lc-examples-more)
                    '((bot lc-value)
                      (clo lc-value) (safe-nth lc-value)
                      (cons (list-of lc-value))))))
lc-par-1
#+end_src

#+RESULTS:
#+begin_src lisp :load no
((TRYABLE 5) (TRYABLE 6) (TRYABLE 5) (TRYABLE 4) (TRYABLE 3) (TRYABLE 4)
 (TRYABLE 3) (TRYABLE 2) (TRYABLE 1) (TRYABLE 3) (TRYABLE 0) (BOT)
 (CONS (BOT) (CONS (TRYABLE 1) (NIL))) (BOT) (NIL)
 (NUM (+ (TRYABLE 5) (TRYABLE 3))) (SAFE-NTH (ZERO) (NIL)) (TRYABLE 4)
 (TRYABLE 2) (BOT) (NIL) (BOT) (CONS (SAFE-NTH (ZERO) (NIL)) (NIL)) (BOT)
 (TRYABLE 1) (ZERO) (TRYABLE 2) (TRYABLE 6) (TRYABLE 7) (TRYABLE 6) (TRYABLE 7)
 (TRYABLE 2) (TRYABLE 2) (TRYABLE 3) (SAFE-NTH (ZERO) (NIL)) (TRYABLE 5)
 (TRYABLE 6) (TRYABLE 5) (TRYABLE 6) (TRYABLE 0) (TRYABLE 3) (ZERO) (TRYABLE 1)
 (TRYABLE 4) (TRYABLE 5) (TRYABLE 4) (TRYABLE 5) (TRYABLE 3) (TRYABLE 1)
 (TRYABLE 3) (TRYABLE 1) (BOT) (CONS (BOT) (TRYABLE 5)) (BOT) (TRYABLE 5)
 (NUM (TRYABLE 3)) (TRYABLE 0) (ZERO) (TRYABLE 2) (TRYABLE 3) (TRYABLE 6)
 (TRYABLE 4) (TRYABLE 6) (TRYABLE 1) (BOT) (+ (ZERO) (ZERO)) (TRYABLE 2) (BOT)
 (CONS (TRYABLE 1) (TRYABLE 4)) (BOT) (TRYABLE 4) (TRYABLE 0) (TRYABLE 3)
 (TRYABLE 5) (TRYABLE 4) (TRYABLE 6) (TRYABLE 2) (TRYABLE 5) (TRYABLE 4)
 (TRYABLE 6) (TRYABLE 5) (TRYABLE 6) (TRYABLE 1) (TRYABLE 3) (TRYABLE 6)
 (TRYABLE 6) (TRYABLE 7) (TRYABLE 0) (TRYABLE 5) (TRYABLE 5)
 (CONS (BOT) (CONS (BOT) (CONS (BOT) (CONS (TRYABLE 2) (TRYABLE 7)))))
 (TRYABLE 6) (TRYABLE 7) (BOT) (ZERO) (TRYABLE 7) (TRYABLE 6) (TRYABLE 8)
 (TRYABLE 2) (TRYABLE 7) (TRYABLE 6) (TRYABLE 8) (TRYABLE 4) (TRYABLE 8)
 (TRYABLE 1) (TRYABLE 3) (TRYABLE 5) (TRYABLE 6) (TRYABLE 7) (TRYABLE 0)
 (TRYABLE 6) (TRYABLE 5) (TRYABLE 7) (TRYABLE 6) (TRYABLE 7) (TRYABLE 1) (ZERO)
 (TRYABLE 4) (TRYABLE 5) (TRYABLE 6) (BOT) (TRYABLE 5) (TRYABLE 4)
 (CONS (BOT) (CONS (TRYABLE 3) (TRYABLE 6))) (TRYABLE 5) (TRYABLE 6)
 (TRYABLE 2) (ZERO) (TRYABLE 5) (TRYABLE 5) (TRYABLE 7) (TRYABLE 2) (TRYABLE 5)
 (TRYABLE 4) (TRYABLE 7) (TRYABLE 3) (TRYABLE 7) (TRYABLE 1) (TRYABLE 2)
 (TRYABLE 5) (CLO (NIL) (BOT)) (TRYABLE 4) (CONS (BOT) (TRYABLE 3)) (TRYABLE 4)
 (CONS (TRYABLE 5) (TRYABLE 3)) (TRYABLE 5) (TRYABLE 1) (TRYABLE 4) (TRYABLE 1)
 (BOT) (NIL) (BOT) (CONS (TRYABLE 2) (NIL)) (CLO (NIL) (BOT)) (TRYABLE 1) (BOT)
 (BOT) (BOT) (NIL) (BOT) (CONS (TRYABLE 1) (NIL)) (TRYABLE 3) (BOT) (TRYABLE 2)
 (SAFE-NTH (ZERO) (NIL)) (TRYABLE 4) (CONS (TRYABLE 2) (TRYABLE 7)) (TRYABLE 6)
 (TRYABLE 7) (TRYABLE 1) (TRYABLE 1) (TRYABLE 2) (BOT) (TRYABLE 5) (TRYABLE 6)
 (TRYABLE 5) (TRYABLE 6) (BOT) (TRYABLE 2) (TRYABLE 3) (TRYABLE 3) (TRYABLE 4)
 (TRYABLE 5) (TRYABLE 4) (TRYABLE 5) (TRYABLE 2) (TRYABLE 1)
 (SAFE-NTH (ZERO) (TRYABLE 5)) (TRYABLE 2) (BOT) (TRYABLE 5) (BOT) (TRYABLE 5)
 (SAFE-NTH (TRYABLE 3) (TRYABLE 5)) (CLO (TRYABLE 5) (TRYABLE 3)) (TRYABLE 2)
 (TRYABLE 0) (TRYABLE 3) (TRYABLE 5) (TRYABLE 3) (TRYABLE 5) (TRYABLE 0)
 (TRYABLE 0) (TRYABLE 0) (TRYABLE 2) (TRYABLE 4) (TRYABLE 6) (TRYABLE 3)
 (CONS (CLO (NIL) (BOT)) (TRYABLE 6)) (TRYABLE 1))
#+end_src

#+begin_src lisp :load no :results output code :exports both
(print-skeleton lc-skeleton lc-par-1)
#+end_src

#+RESULTS:
#+begin_src lisp :load no
(WITH-SKELETON (:TYPE (FUNCTION (TERM (LIST-OF LC-VALUE)) LC-VALUE)
                :LAZY-EVALUATION-P T)
  (LABELS ((ARITH-1 (LC-VALUE0 NAT1)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE LC-VALUE0
               (CLO (EVAL-TOPLEVEL (CLO-BODY LC-VALUE0) (CLO-ENV LC-VALUE0)))
               (NUM (NUM (+ NAT1 (NUM-VALUE LC-VALUE0))))
               ((EQL BOT) 'BOT)))
           (ARITH-2 (LC-VALUE2 TERM3 LIST-OF-LC-VALUE-4)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE LC-VALUE2
               (CLO (EVAL-TOPLEVEL TERM3 LIST-OF-LC-VALUE-4))
               (NUM
                (ARITH-1 (EVAL-TOPLEVEL TERM3 LIST-OF-LC-VALUE-4)
                 (NUM-VALUE LC-VALUE2)))
               ((EQL BOT) LC-VALUE2)))
           (ARITH-EVAL (ARITH-TERM5 LIST-OF-LC-VALUE-6)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE ARITH-TERM5
               (LIT (NUM (LIT-NUM ARITH-TERM5)))
               (ADD
                (ARITH-2
                 (EVAL-TOPLEVEL (ADD-R ARITH-TERM5) LIST-OF-LC-VALUE-6)
                 (ADD-L ARITH-TERM5) LIST-OF-LC-VALUE-6))
               ((EQL BOT) (ARITH-1 'BOT (+ (ZERO) (ZERO))))))
           (COND-1 (NAT7 TERM8 TERM9 LIST-OF-LC-VALUE-10)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE NAT7
               ((INTEGER 0 0)
                (COND-2 (EVAL-TOPLEVEL TERM9 LIST-OF-LC-VALUE-10) TERM9 TERM8
                 LIST-OF-LC-VALUE-10))
               ((AND FIXNUM (INTEGER 1)) 'BOT)))
           (COND-2 (LC-VALUE11 TERM12 TERM13 LIST-OF-LC-VALUE-14)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE LC-VALUE11
               (CLO
                (COND-2
                 (EVAL-TOPLEVEL (CLO-BODY LC-VALUE11) LIST-OF-LC-VALUE-14)
                 TERM13 TERM12 LIST-OF-LC-VALUE-14))
               (NUM
                (COND-2
                 (COND-1 (NUM-VALUE LC-VALUE11) TERM12 TERM13
                  LIST-OF-LC-VALUE-14)
                 TERM13 TERM12 LIST-OF-LC-VALUE-14))
               ((EQL BOT) (EVAL-TOPLEVEL TERM13 LIST-OF-LC-VALUE-14))))
           (COND-EVAL (COND-TERM15 LIST-OF-LC-VALUE-16)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE COND-TERM15
               (IFZ
                (COND-2
                 (EVAL-TOPLEVEL (IFZ-TEST COND-TERM15) LIST-OF-LC-VALUE-16)
                 (IFZ-ELSE COND-TERM15) (IFZ-THEN COND-TERM15)
                 LIST-OF-LC-VALUE-16))))
           (LC-1 (LC-VALUE17 LC-VALUE18)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE LC-VALUE17
               (CLO LC-VALUE17)
               (NUM (CLO 'NIL 'BOT))
               ((EQL BOT) LC-VALUE17)))
           (LC-2 (LC-VALUE19 TERM20 LIST-OF-LC-VALUE-21)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE LC-VALUE19
               (CLO
                (LC-2 (SAFE-NTH (ZERO) 'NIL) (CLO-BODY LC-VALUE19)
                 (CONS (EVAL-TOPLEVEL TERM20 LIST-OF-LC-VALUE-21)
                       LIST-OF-LC-VALUE-21)))
               (NUM 'BOT)
               ((EQL BOT) (EVAL-TOPLEVEL TERM20 LIST-OF-LC-VALUE-21))))
           (LC-EVAL (LC-TERM22 LIST-OF-LC-VALUE-23)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE LC-TERM22
               (VAR (SAFE-NTH (VAR-INDEX LC-TERM22) LIST-OF-LC-VALUE-23))
               (LAM
                (LC-1 (CLO LIST-OF-LC-VALUE-23 (LAM-BODY LC-TERM22))
                 (EVAL-TOPLEVEL (LAM-BODY LC-TERM22) LIST-OF-LC-VALUE-23)))
               (APP
                (LC-2
                 (EVAL-TOPLEVEL (APP-OP LC-TERM22)
                  (CONS (CLO 'NIL 'BOT) LIST-OF-LC-VALUE-23))
                 (APP-ARG LC-TERM22) LIST-OF-LC-VALUE-23))))
           (EVAL-TOPLEVEL (TERM ENV)
             (ETYPECASE TERM
               (ARITH-TERM (ARITH-EVAL TERM ENV))
               (COND-TERM (COND-EVAL TERM ENV))
               (LC-TERM (LC-EVAL TERM ENV)))))
    (LIST #'ARITH-1 #'ARITH-2 #'ARITH-EVAL #'COND-1 #'COND-2 #'COND-EVAL #'LC-1
          #'LC-2 #'LC-EVAL #'EVAL-TOPLEVEL)))
NIL
#+end_src

*** Exceptions
#+begin_src lisp
(uiop:define-package #:genrec/experiments/exception
    (:mix #:cl #:genrec #:serapeum))
(in-package #:genrec/experiments/exception)
#+end_src

#+begin_src lisp
(define-adt arith-term
  (lit (num nat))
  (add (l term) (r term)))
(define-adt cond-term
  (ifz (test term) (then term) (else term)))
(define-adt lc-term
  (var (index nat))
  (lam (body term))
  (app (op term) (arg term)))
(define-adt exc-term
  (err (code nat))
  (handle (tryer term) (catcher term)))
(define-union term arith-term cond-term lc-term exc-term)
(define-adt value
  (clo (env (list-of value)) (body term))
  (num (value nat))
  (erv (code nat)))
(defun safe-nth (n l)
  (let ((cons (nthcdr n l)))
    (if cons (car cons) (erv 0))))
(setf (get 'safe-nth 'arg-types) (lambda (r) `(nat (list-of ,r))))
(defproblem exc-eval
    (term (list-of exc-value)) exc-value
    (term env)
  (etypecase term
    (var (safe-nth (var-index term) env))
    (app (let ((op (exc-eval (app-op term) env))
               (arg (exc-eval (app-arg term) env)))
           (typecase op
             (clo (exc-eval (clo-body op) (cons arg (clo-env op))))
             (erv op)
             (t (erv 1)))))
    (lam (clo env (lam-body term)))
    (lit (num (lit-num term)))
    (add (let ((l (exc-eval (add-l term) env))
               (r (exc-eval (add-r term) env)))
           (typecase l
             (erv l)
             (num (typecase r
                    (erv r)
                    (num (num (+ (num-value l) (num-value r))))
                    (t (erv 1))))
             (t (erv 1)))))
    (ifz (let ((test (exc-eval (ifz-test term) env)))
           (typecase test
             (num (if (zerop (num-value test))
                      (exc-eval (ifz-then term) env)
                      (exc-eval (ifz-else term) env)))
             (erv test)
             (t (erv 1)))))
    (err (erv (err-code term)))
    (handle (let ((v (exc-eval (handle-tryer term) env)))
              (if (erv-p v)
                  (exc-eval (handle-catcher term) (cons (num (erv-code v)) env))
                  v)))))
(def arith-examples
  (inputs-to-examples exc-eval
    ((lit 0) nil)
    ((lit 1) nil)
    ((err 0) nil)
    ((err 1) nil)
    ((add (lit 0) (err 0)) nil)
    ((add (err 0) (lit 0)) nil)
    ((add (err 0) (lit 2)) nil)
    ((add (lit 0) (err 1)) nil)
    ((add (lit 2) (lit 0)) nil)
    ((add (lit 0) (lit 2)) nil)
    ((add (lit 1) (lit 2)) nil)))
(def cond-examples
  (inputs-to-examples exc-eval
    ((ifz (lit 0) (lit 0) (lit 2)) nil)
    ((ifz (lit 1) (lit 0) (lit 2)) nil)
    ((ifz (lit 0) (add (lit 0) (lit 2)) (lit 0)) nil)
    ((ifz (lit 0) (add (lit 1) (lit 2)) (lit 0)) nil)
    ((ifz (lit 0) (err 0) (err 1)) nil)
    ((ifz (lit 1) (lit 0) (add (lit 0) (lit 2))) nil)
    ((ifz (lit 1) (lit 0) (add (lit 1) (lit 2))) nil)
    ((ifz (lit 1) (err 0) (err 1)) nil)))
(def skeleton
  (call-graph-skeleton
   (arith-1 (function (value nat) value)
            arith-1 arith-2 eval-toplevel)
   (arith-2 (function (value term (list-of value)) value)
            arith-1 arith-2 eval-toplevel)
   (arith-eval (function (arith-term (list-of value)) value)
               arith-1 arith-2 eval-toplevel)
   (cond-1 (function (nat term term (list-of value)) value)
           cond-1 cond-2 eval-toplevel)
   (cond-2 (function (value term term (list-of value)) value)
           cond-1 cond-2 eval-toplevel)
   (cond-eval (function (cond-term (list-of value)) value)
              cond-1 cond-2 eval-toplevel)
   (lc-1 (function (value value) value)
         lc-1 lc-2 eval-toplevel)
   (lc-2 (function (value term (list-of value)) value)
         lc-1 lc-2 eval-toplevel)
   (lc-eval (function (lc-term (list-of value)) value)
            lc-1 lc-2 eval-toplevel)
   (exc-1 (function (value term (list-of value)) value)
          exc-1 eval-toplevel)
   (exc-eval (function (exc-term (list-of value)) value)
             exc-1 eval-toplevel)
   (eval-toplevel (function (term (list-of value)) value)
                  :code (term env)
                  (etypecase term
                    (arith-term (arith-eval term env))
                    (cond-term (cond-eval term env))
                    (lc-term (lc-eval term env))
                    (exc-term (exc-eval term env))))))
#+end_src

#+begin_src lisp :load no
(def arith-par
  (let ((genrec::*frozen-holes*
          (genrec::holes-for-functions skeleton '(6 7 8 9))))
    (solve-skeleton 'skeleton (append arith-examples cond-examples)
                    '((+ nat) (succ nat) (num value) (erv value)))))
arith-par
#+end_src

#+RESULTS:
#+begin_src lisp :load no
((TRYABLE 2) (TRYABLE 6) (NUM (ZERO)) (TRYABLE 4) (TRYABLE 3) (TRYABLE 4)
 (TRYABLE 3) (TRYABLE 5) (TRYABLE 2) (TRYABLE 5) (NUM (ZERO)) (LIT (TRYABLE 3))
 (NIL) (LIT (+ (TRYABLE 5) (TRYABLE 3))) (NIL) (TRYABLE 2) (TRYABLE 2)
 (SUCC (TRYABLE 3)) (TRYABLE 2) (LIT (TRYABLE 3)) (NIL) (LIT (TRYABLE 3)) (NIL)
 (TRYABLE 4) (TRYABLE 0) (ZERO) (TRYABLE 1) (TRYABLE 6) (TRYABLE 7) (TRYABLE 6)
 (TRYABLE 3) (TRYABLE 5) (TRYABLE 2) (TRYABLE 3) (TRYABLE 2) (TRYABLE 5)
 (TRYABLE 6) (TRYABLE 5) (TRYABLE 6) (TRYABLE 0) (TRYABLE 1)
 (+ (TRYABLE 3) (TRYABLE 3)) (TRYABLE 0) (TRYABLE 5) (TRYABLE 6) (TRYABLE 5)
 (TRYABLE 6) (TRYABLE 4) (TRYABLE 2) (TRYABLE 3) (ERV (ZERO)) (LIT (TRYABLE 3))
 (TRYABLE 5) (LIT (TRYABLE 3)) (TRYABLE 5) (NUM (TRYABLE 3)) (TRYABLE 0) (ZERO)
 (TRYABLE 2) (TRYABLE 4) (TRYABLE 6) (TRYABLE 3) (TRYABLE 6) (TRYABLE 1)
 (TRYABLE 3) (TRYABLE 5) (TRYABLE 4) (TRYABLE 6) (TRYABLE 1) (TRYABLE 4)
 (TRYABLE 5) (TRYABLE 6) (TRYABLE 4) (TRYABLE 6) (TRYABLE 2) (TRYABLE 3)
 (TRYABLE 5) (TRYABLE 6) (TRYABLE 7) (TRYABLE 0) (TRYABLE 6) (TRYABLE 6)
 (TRYABLE 7) (TRYABLE 5) (TRYABLE 7) (TRYABLE 1) (ZERO) (TRYABLE 7) (TRYABLE 7)
 (TRYABLE 8) (TRYABLE 0) (TRYABLE 4) (TRYABLE 6) (TRYABLE 3) (TRYABLE 4)
 (TRYABLE 3) (TRYABLE 0) (TRYABLE 3) (TRYABLE 5) (TRYABLE 6) (TRYABLE 7)
 (TRYABLE 0) (TRYABLE 6) (TRYABLE 6) (TRYABLE 7) (TRYABLE 5) (TRYABLE 7)
 (TRYABLE 0) (TRYABLE 3) (TRYABLE 5) (TRYABLE 6) (TRYABLE 7) (TRYABLE 4)
 (TRYABLE 6) (TRYABLE 6) (TRYABLE 7) (TRYABLE 6) (TRYABLE 7) (TRYABLE 2) (ZERO)
 (TRYABLE 3) (TRYABLE 4) (TRYABLE 7) (TRYABLE 2) (TRYABLE 4) (TRYABLE 5)
 (TRYABLE 7) (TRYABLE 3) (TRYABLE 7) (TRYABLE 1) (NUM (ZERO)) (NUM (ZERO))
 (NUM (ZERO)) (LIT (ZERO)) (NIL) (LIT (ZERO)) (NIL) (NUM (ZERO)) (NUM (ZERO))
 (NUM (ZERO)) (NUM (ZERO)) (LIT (ZERO)) (NIL) (LIT (ZERO)) (NIL) (NUM (ZERO))
 (NUM (ZERO)) (NUM (ZERO)) (NUM (ZERO)) (LIT (ZERO)) (NIL) (LIT (ZERO)) (NIL)
 (NUM (ZERO)) (NUM (ZERO)) (NUM (ZERO)) (NUM (ZERO)) (LIT (ZERO)) (NIL)
 (LIT (ZERO)) (NIL) (NUM (ZERO)) (NUM (ZERO)) (NUM (ZERO)) (NUM (ZERO))
 (LIT (ZERO)) (NIL) (LIT (ZERO)) (NIL) (NUM (ZERO)) (NUM (ZERO)) (NUM (ZERO))
 (NUM (ZERO)) (LIT (ZERO)) (NIL) (LIT (ZERO)) (NIL) (NUM (ZERO)) (NUM (ZERO))
 (NUM (ZERO)) (NUM (ZERO)) (LIT (ZERO)) (NIL) (LIT (ZERO)) (NIL) (NUM (ZERO))
 (NUM (ZERO)) (NUM (ZERO)) (NUM (ZERO)) (LIT (ZERO)) (NIL) (LIT (ZERO)) (NIL)
 (NUM (ZERO)) (NUM (ZERO)) (NUM (ZERO)) (NUM (ZERO)) (LIT (ZERO)) (NIL)
 (LIT (ZERO)) (NIL) (NUM (ZERO)) (NUM (ZERO)) (LIT (ZERO)) (NIL) (LIT (ZERO))
 (NIL) (NUM (ZERO)) (NUM (ZERO)) (LIT (ZERO)) (NIL) (LIT (ZERO)) (NIL)
 (NUM (ZERO)) (NUM (ZERO)) (LIT (ZERO)) (NIL) (LIT (ZERO)) (NIL) (NUM (ZERO))
 (TRYABLE 0) (LIT (TRYABLE 2)) (TRYABLE 4) (LIT (TRYABLE 2)) (TRYABLE 4)
 (ERV (TRYABLE 2)) (ERV (SUCC (ZERO))) (TRYABLE 2) (TRYABLE 5) (TRYABLE 2)
 (TRYABLE 5) (TRYABLE 0))
#+end_src

#+begin_src lisp
(def lc-examples
  (inputs-to-examples exc-eval
    ((lam (var 0)) nil)
    ((lam (var 1)) nil)
    ((lam (var 0)) (list (num 0)))
    ((lam (var 1)) (list (num 0)))
    ((lam (var 1)) (list (clo nil (var 0))))
    ((var 0) (list (clo nil (var 0))))
    ((var 1) (list (clo nil (var 0))))
    ((lam (lam (var 0))) nil)
    ((app (lam (var 0)) (lam (var 0))) nil)
    ((app (var 0) (var 0)) nil)
    ((app (lam (var 0)) (var 0)) nil)
    ((app (var 0) (lam (var 0))) nil)
    ((app (app (lam (lam (var 0))) (lam (var 0))) (lam (var 0))) nil)
    ((app (app (lam (lam (var 0))) (lam (var 1))) (lam (var 0))) nil)
    ((app (app (lam (lam (var 0))) (lam (var 0))) (lam (var 1))) nil)
    ((app (lam (lam (var 0))) (lam (var 0))) nil)
    ((app (lam (lam (var 0))) (lam (var 1))) nil)
    ((app (lam (lam (var 1))) (lam (var 0))) nil)
    ((app (lam (var 0)) (lit 0)) nil)
    ((app (lam (add (lit 1) (var 0))) (lit 0)) nil)
    ((app (lam (add (lit 0) (var 0))) (lit 1)) nil)
    ((app (lit 0) (lit 0)) nil)))
#+end_src

#+begin_src lisp :load no
(def lc-par
  (let ((genrec::*frozen-holes*
          (union (genrec::compute-live-holes skeleton (append arith-examples cond-examples) arith-par)
                 (genrec::holes-for-functions skeleton '(9))))
        (genrec::*initial-par* arith-par))
    (solve-skeleton 'skeleton lc-examples
                    '((erv value) (succ nat)
                      (clo value) (safe-nth value)
                      (cons (list-of value))))))
lc-par
#+end_src

#+RESULTS:
#+begin_src lisp :load no
((ERV (TRYABLE 6)) (TRYABLE 6) (TRYABLE 2) (TRYABLE 4) (TRYABLE 3) (TRYABLE 4)
 (TRYABLE 3) (TRYABLE 2) (TRYABLE 4) (TRYABLE 3) (TRYABLE 1)
 (LIT (SUCC (TRYABLE 3)))
 (CONS (NUM (ZERO))
       (CONS (TRYABLE 4) (CONS (NUM (ZERO)) (CONS (NUM (TRYABLE 3)) (NIL)))))
 (LIT (+ (TRYABLE 5) (TRYABLE 3))) (NIL) (TRYABLE 2) (TRYABLE 1) (TRYABLE 3)
 (TRYABLE 4) (LIT (TRYABLE 5)) (NIL) (LIT (TRYABLE 5)) (NIL) (TRYABLE 4)
 (TRYABLE 0) (ZERO) (TRYABLE 0) (TRYABLE 6) (CONS (TRYABLE 5) (TRYABLE 7))
 (TRYABLE 4) (CONS (NUM (ZERO)) (TRYABLE 3)) (TRYABLE 2) (TRYABLE 2)
 (TRYABLE 3) (TRYABLE 1) (TRYABLE 5) (TRYABLE 6) (TRYABLE 5) (TRYABLE 6)
 (TRYABLE 0) (TRYABLE 1) (TRYABLE 3) (TRYABLE 0) (TRYABLE 5) (TRYABLE 6)
 (TRYABLE 5) (TRYABLE 6) (TRYABLE 4) (ERV (ZERO)) (SUCC (TRYABLE 3))
 (TRYABLE 0) (LIT (TRYABLE 3)) (TRYABLE 5) (LIT (TRYABLE 3))
 (CONS (NUM (ZERO)) (TRYABLE 5)) (NUM (TRYABLE 3)) (TRYABLE 0) (SUCC (ZERO))
 (TRYABLE 2) (TRYABLE 4) (TRYABLE 6) (TRYABLE 3) (TRYABLE 6) (TRYABLE 1)
 (TRYABLE 3) (TRYABLE 4) (TRYABLE 4) (TRYABLE 6) (TRYABLE 2) (TRYABLE 4)
 (TRYABLE 4) (CONS (NUM (ZERO)) (TRYABLE 6)) (TRYABLE 4) (TRYABLE 6)
 (TRYABLE 2) (TRYABLE 3) (TRYABLE 5) (TRYABLE 6) (TRYABLE 7) (TRYABLE 0)
 (TRYABLE 6) (TRYABLE 6) (TRYABLE 7) (TRYABLE 5)
 (CONS (NUM (ZERO)) (TRYABLE 7)) (TRYABLE 1) (ZERO) (TRYABLE 7) (TRYABLE 6)
 (TRYABLE 8) (TRYABLE 0) (TRYABLE 7) (TRYABLE 6)
 (CONS (NUM (ZERO)) (TRYABLE 8)) (TRYABLE 7) (TRYABLE 8) (TRYABLE 5)
 (TRYABLE 3) (TRYABLE 5) (TRYABLE 6) (TRYABLE 7) (ERV (TRYABLE 3)) (TRYABLE 5)
 (TRYABLE 6) (TRYABLE 7) (TRYABLE 6) (TRYABLE 7) (TRYABLE 0) (TRYABLE 3)
 (TRYABLE 6) (TRYABLE 6) (CONS (NUM (ZERO)) (TRYABLE 7)) (TRYABLE 1)
 (TRYABLE 6) (TRYABLE 6) (TRYABLE 7) (TRYABLE 6) (TRYABLE 7) (TRYABLE 2)
 (SUCC (ZERO)) (TRYABLE 4) (TRYABLE 4) (TRYABLE 7) (TRYABLE 2) (TRYABLE 4)
 (TRYABLE 5) (TRYABLE 7) (TRYABLE 3) (TRYABLE 7) (TRYABLE 1) (TRYABLE 6)
 (TRYABLE 0) (TRYABLE 2) (TRYABLE 4) (TRYABLE 3) (TRYABLE 4)
 (CONS (TRYABLE 6) (TRYABLE 3)) (TRYABLE 2) (TRYABLE 0) (TRYABLE 1) (TRYABLE 4)
 (LIT (TRYABLE 3)) (CONS (TRYABLE 4) (CONS (TRYABLE 0) (NIL)))
 (LIT (TRYABLE 3)) (NIL) (ERV (SUCC (ZERO))) (TRYABLE 5) (TRYABLE 1)
 (TRYABLE 5) (LIT (TRYABLE 3)) (CONS (TRYABLE 2) (CONS (TRYABLE 2) (NIL)))
 (LIT (TRYABLE 3)) (CONS (TRYABLE 1) (NIL)) (TRYABLE 5) (TRYABLE 2) (TRYABLE 5)
 (TRYABLE 0) (TRYABLE 4) (TRYABLE 7) (TRYABLE 6) (TRYABLE 7) (TRYABLE 2)
 (TRYABLE 0) (TRYABLE 2) (TRYABLE 2) (TRYABLE 5) (CONS (TRYABLE 4) (TRYABLE 6))
 (TRYABLE 5) (TRYABLE 6) (SAFE-NTH (TRYABLE 3) (TRYABLE 6)) (TRYABLE 2)
 (TRYABLE 0) (TRYABLE 2) (TRYABLE 5) (TRYABLE 6) (TRYABLE 5)
 (CONS (TRYABLE 1) (CONS (TRYABLE 4) (TRYABLE 6))) (TRYABLE 4) (TRYABLE 0)
 (TRYABLE 1) (TRYABLE 2) (LIT (SUCC (TRYABLE 3))) (TRYABLE 5) (LIT (TRYABLE 3))
 (TRYABLE 5) (TRYABLE 1) (ERV (ZERO)) (CLO (TRYABLE 5) (TRYABLE 3))
 (ERV (ZERO)) (TRYABLE 3) (TRYABLE 5) (TRYABLE 3) (TRYABLE 5) (TRYABLE 0)
 (TRYABLE 2) (TRYABLE 1) (TRYABLE 2) (TRYABLE 4) (TRYABLE 6) (TRYABLE 3)
 (TRYABLE 6) (TRYABLE 0) (NUM (ZERO)) (LIT (ZERO)) (NIL) (LIT (ZERO)) (NIL)
 (NUM (ZERO)) (NUM (ZERO)) (LIT (ZERO)) (NIL) (LIT (ZERO)) (NIL) (NUM (ZERO))
 (NUM (ZERO)) (LIT (ZERO)) (NIL) (LIT (ZERO)) (NIL) (NUM (ZERO)) (TRYABLE 1)
 (LIT (TRYABLE 2)) (CONS (TRYABLE 0) (CONS (NUM (ZERO)) (TRYABLE 4)))
 (LIT (TRYABLE 2)) (TRYABLE 4) (ERV (TRYABLE 2)) (TRYABLE 0) (TRYABLE 3)
 (TRYABLE 5) (TRYABLE 3) (TRYABLE 5) (TRYABLE 1))
#+end_src

#+begin_src lisp
(def exc-examples
  (inputs-to-examples exc-eval
    ((handle (err 0) (var 0)) nil)
    ((handle (err 1) (var 0)) nil)
    ((handle (lit 1) (var 0)) nil)
    ((handle (add (lit 1) (lit 2)) (var 0)) nil)))
#+end_src

#+begin_src lisp :load no
(def exc-par
  (let ((genrec::*frozen-holes*
          (genrec::compute-live-holes skeleton
                                      (append arith-examples cond-examples lc-examples)
                                      lc-par))
        (genrec::*initial-par* lc-par))
    (solve-skeleton 'skeleton exc-examples
                    '((erv value) (succ nat)))))
exc-par
#+end_src

#+RESULTS:
#+begin_src lisp :load no
((ERV (ZERO)) (TRYABLE 6) (TRYABLE 5) (TRYABLE 4) (TRYABLE 3) (TRYABLE 4)
 (TRYABLE 3) (TRYABLE 2) (TRYABLE 4) (TRYABLE 3) (TRYABLE 4) (LIT (TRYABLE 5))
 (NIL) (LIT (+ (TRYABLE 5) (TRYABLE 3))) (NIL) (TRYABLE 2) (TRYABLE 0)
 (TRYABLE 5) (TRYABLE 2) (LIT (TRYABLE 5)) (NIL) (LIT (TRYABLE 3)) (NIL)
 (TRYABLE 4) (TRYABLE 0) (ZERO) (TRYABLE 1) (TRYABLE 6) (TRYABLE 7) (TRYABLE 4)
 (TRYABLE 3) (TRYABLE 0) (TRYABLE 2) (TRYABLE 3) (TRYABLE 0) (TRYABLE 5)
 (TRYABLE 6) (TRYABLE 5) (TRYABLE 6) (TRYABLE 0) (TRYABLE 0) (SUCC (TRYABLE 3))
 (TRYABLE 0) (TRYABLE 5) (TRYABLE 6) (TRYABLE 5) (TRYABLE 6) (TRYABLE 4)
 (TRYABLE 2) (TRYABLE 3) (ERV (ZERO)) (LIT (SUCC (TRYABLE 3))) (TRYABLE 5)
 (LIT (TRYABLE 3)) (TRYABLE 5) (NUM (TRYABLE 3)) (ERV (ZERO)) (ZERO)
 (TRYABLE 2) (TRYABLE 4) (TRYABLE 6) (TRYABLE 3) (TRYABLE 6) (TRYABLE 1)
 (SUCC (TRYABLE 3)) (TRYABLE 4) (TRYABLE 4) (TRYABLE 6) (TRYABLE 1) (TRYABLE 5)
 (TRYABLE 4) (TRYABLE 6) (TRYABLE 4) (TRYABLE 6) (TRYABLE 2) (TRYABLE 3)
 (TRYABLE 5) (TRYABLE 6) (TRYABLE 7) (TRYABLE 0) (TRYABLE 6) (TRYABLE 6)
 (TRYABLE 7) (TRYABLE 5) (TRYABLE 7) (TRYABLE 1) (ZERO) (TRYABLE 4) (TRYABLE 7)
 (TRYABLE 3) (ERV (ZERO)) (TRYABLE 7) (TRYABLE 7) (TRYABLE 3) (TRYABLE 6)
 (TRYABLE 3) (ERV (ZERO)) (TRYABLE 3) (TRYABLE 5) (TRYABLE 6) (TRYABLE 7)
 (ERV (TRYABLE 3)) (TRYABLE 6) (TRYABLE 5) (TRYABLE 7) (TRYABLE 6) (TRYABLE 7)
 (TRYABLE 0) (TRYABLE 3) (TRYABLE 5) (TRYABLE 5) (TRYABLE 7) (TRYABLE 1)
 (TRYABLE 6) (TRYABLE 5) (TRYABLE 7) (TRYABLE 6) (TRYABLE 7) (TRYABLE 2) (ZERO)
 (TRYABLE 3) (TRYABLE 4) (TRYABLE 7) (TRYABLE 2) (TRYABLE 4) (TRYABLE 5)
 (TRYABLE 7) (TRYABLE 3) (TRYABLE 7) (TRYABLE 1) (TRYABLE 2) (TRYABLE 0)
 (TRYABLE 1) (TRYABLE 4) (TRYABLE 3) (TRYABLE 4) (CONS (TRYABLE 6) (TRYABLE 3))
 (TRYABLE 2) (TRYABLE 4) (TRYABLE 1) (TRYABLE 5) (LIT (TRYABLE 3)) (NIL)
 (LIT (TRYABLE 3)) (NIL) (ERV (SUCC (ZERO))) (TRYABLE 1) (ERV (ZERO))
 (TRYABLE 5) (LIT (TRYABLE 3)) (CONS (ERV (ZERO)) (NIL)) (LIT (TRYABLE 3))
 (NIL) (TRYABLE 5) (TRYABLE 1) (TRYABLE 5) (TRYABLE 0) (TRYABLE 4) (TRYABLE 7)
 (TRYABLE 6) (TRYABLE 7) (TRYABLE 2) (TRYABLE 2) (TRYABLE 1) (TRYABLE 2)
 (TRYABLE 5) (TRYABLE 6) (TRYABLE 5) (TRYABLE 6)
 (SAFE-NTH (TRYABLE 3) (TRYABLE 6)) (TRYABLE 4) (TRYABLE 1) (TRYABLE 1)
 (TRYABLE 5) (TRYABLE 6) (TRYABLE 5) (TRYABLE 6) (TRYABLE 4) (TRYABLE 1)
 (TRYABLE 0) (TRYABLE 2) (LIT (SUCC (TRYABLE 3))) (TRYABLE 5) (LIT (TRYABLE 3))
 (TRYABLE 5) (TRYABLE 1) (ERV (ZERO)) (CLO (TRYABLE 5) (TRYABLE 3)) (TRYABLE 0)
 (TRYABLE 3) (TRYABLE 5) (TRYABLE 3) (TRYABLE 5) (TRYABLE 0) (TRYABLE 2)
 (TRYABLE 1) (TRYABLE 2) (TRYABLE 4) (TRYABLE 6) (TRYABLE 3) (TRYABLE 6)
 (TRYABLE 0) (TRYABLE 1) (TRYABLE 3) (TRYABLE 2) (TRYABLE 5) (TRYABLE 6)
 (TRYABLE 1) (ERV (TRYABLE 2)) (TRYABLE 4) (TRYABLE 5) (TRYABLE 4) (TRYABLE 5)
 (TRYABLE 0) (ERV (ZERO)) (TRYABLE 4) (TRYABLE 5) (LIT (TRYABLE 2)) (TRYABLE 5)
 (TRYABLE 1) (ERV (ZERO)) (LIT (TRYABLE 2)) (TRYABLE 4) (LIT (TRYABLE 2))
 (TRYABLE 4) (ERV (TRYABLE 2)) (TRYABLE 1) (TRYABLE 3) (TRYABLE 5) (TRYABLE 2)
 (TRYABLE 5) (TRYABLE 0))
#+end_src

#+begin_src lisp :load no :results output code :exports both
(print-skeleton skeleton exc-par)
#+end_src

#+RESULTS:
#+begin_src lisp :load no

(WITH-SKELETON (:TYPE (FUNCTION (TERM (LIST-OF VALUE)) VALUE)
                :LAZY-EVALUATION-P T)
  (LABELS ((ARITH-1 (VALUE0 NAT1)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE VALUE0
               (CLO (EVAL-TOPLEVEL (CLO-BODY VALUE0) (CLO-ENV VALUE0)))
               (NUM (EVAL-TOPLEVEL (LIT (+ NAT1 (NUM-VALUE VALUE0))) 'NIL))
               (ERV VALUE0)))
           (ARITH-2 (VALUE2 TERM3 LIST-OF-VALUE-4)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE VALUE2
               (CLO
                (ARITH-1
                 (ARITH-1
                  (ARITH-1 (ARITH-1 (ARITH-1 VALUE28 (ZERO)) (ZERO)) (ZERO))
                  (ZERO))
                 (ZERO)))
               (NUM
                (ARITH-1 (EVAL-TOPLEVEL TERM3 LIST-OF-VALUE-4)
                 (NUM-VALUE VALUE2)))
               (ERV VALUE2)))
           (ARITH-EVAL (ARITH-TERM5 LIST-OF-VALUE-6)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE ARITH-TERM5
               (LIT (NUM (LIT-NUM ARITH-TERM5)))
               (ADD
                (ARITH-2 (EVAL-TOPLEVEL (ADD-L ARITH-TERM5) LIST-OF-VALUE-6)
                 (ADD-R ARITH-TERM5) LIST-OF-VALUE-6))))
           (COND-1 (NAT7 TERM8 TERM9 LIST-OF-VALUE-10)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE NAT7
               ((INTEGER 0 0) (EVAL-TOPLEVEL TERM8 LIST-OF-VALUE-10))
               ((AND FIXNUM (INTEGER 1))
                (COND-2 (COND-1 (1- NAT7) TERM8 TERM9 LIST-OF-VALUE-10) TERM9
                 TERM9 LIST-OF-VALUE-10))))
           (COND-2 (VALUE11 TERM12 TERM13 LIST-OF-VALUE-14)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE VALUE11
               (CLO (ERV (ZERO)))
               (NUM
                (COND-1 (NUM-VALUE VALUE11) TERM12 TERM13 LIST-OF-VALUE-14))
               (ERV (EVAL-TOPLEVEL TERM13 LIST-OF-VALUE-14))))
           (COND-EVAL (COND-TERM15 LIST-OF-VALUE-16)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE COND-TERM15
               (IFZ
                (COND-2
                 (EVAL-TOPLEVEL (IFZ-TEST COND-TERM15) LIST-OF-VALUE-16)
                 (IFZ-THEN COND-TERM15) (IFZ-ELSE COND-TERM15)
                 LIST-OF-VALUE-16))))
           (LC-1 (VALUE17 VALUE18)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE VALUE17
               (CLO
                (EVAL-TOPLEVEL (CLO-BODY VALUE17)
                 (CONS VALUE18 (CLO-ENV VALUE17))))
               (NUM (ERV (SUCC (ZERO))))
               (ERV VALUE18)))
           (LC-2 (VALUE19 TERM20 LIST-OF-VALUE-21)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE VALUE19
               (CLO (EVAL-TOPLEVEL TERM20 LIST-OF-VALUE-21))
               (NUM (SAFE-NTH (NUM-VALUE VALUE19) LIST-OF-VALUE-21))
               (ERV VALUE19)))
           (LC-EVAL (LC-TERM22 LIST-OF-VALUE-23)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE LC-TERM22
               (VAR
                (LC-2
                 (EVAL-TOPLEVEL (LIT (VAR-INDEX LC-TERM22)) LIST-OF-VALUE-23)
                 (LIT (SUCC (VAR-INDEX LC-TERM22))) LIST-OF-VALUE-23))
               (LAM
                (LC-1 (ERV (ZERO))
                 (CLO LIST-OF-VALUE-23 (LAM-BODY LC-TERM22))))
               (APP
                (LC-1 (EVAL-TOPLEVEL (APP-OP LC-TERM22) LIST-OF-VALUE-23)
                 (LC-2 (EVAL-TOPLEVEL (APP-OP LC-TERM22) LIST-OF-VALUE-23)
                  (APP-ARG LC-TERM22) LIST-OF-VALUE-23)))))
           (EXC-1 (VALUE24 TERM25 LIST-OF-VALUE-26)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE VALUE24
               (CLO (EVAL-TOPLEVEL TERM25 LIST-OF-VALUE-26))
               (NUM (EXC-1 (ERV (NUM-VALUE VALUE24)) TERM25 LIST-OF-VALUE-26))
               (ERV
                (EVAL-TOPLEVEL (LIT (ERV-CODE VALUE24)) LIST-OF-VALUE-26))))
           (EXC-EVAL (EXC-TERM27 LIST-OF-VALUE-28)
             (GENREC::CHECK-RESOURCE-LIMIT)
             (ETYPECASE EXC-TERM27
               (ERR (ERV (ERR-CODE EXC-TERM27)))
               (HANDLE
                (EXC-1
                 (EVAL-TOPLEVEL (HANDLE-TRYER EXC-TERM27) LIST-OF-VALUE-28)
                 (HANDLE-CATCHER EXC-TERM27) LIST-OF-VALUE-28))))
           (EVAL-TOPLEVEL (TERM ENV)
             (ETYPECASE TERM
               (ARITH-TERM (ARITH-EVAL TERM ENV))
               (COND-TERM (COND-EVAL TERM ENV))
               (LC-TERM (LC-EVAL TERM ENV))
               (EXC-TERM (EXC-EVAL TERM ENV)))))
    (LIST #'ARITH-1 #'ARITH-2 #'ARITH-EVAL #'COND-1 #'COND-2 #'COND-EVAL #'LC-1
          #'LC-2 #'LC-EVAL #'EXC-1 #'EXC-EVAL #'EVAL-TOPLEVEL)))
NIL
#+end_src


# Local Variables:
# org-edit-src-content-indentation: 0
# org-adapt-indentation: nil
# org-export-use-babel: nil
# org-hide-emphasis-markers: nil
# org-link-abbrev-alist: (("wiki" . "https://en.wikipedia.org/wiki/"))
# org-html-htmlize-output-type: css
# End:
